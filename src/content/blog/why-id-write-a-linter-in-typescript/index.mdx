---
description: "Native speed for parsing and type checking is wonderful, but I think there are huge benefits to writing lint rules in the same language as the code they analyze. Here's why."
image:
  alt: "The face of the man from Normal Rockwell's 'Freedom of Speech': standing up and looking up stoically, about to speak."
  src: "~/assets/blog/freedom-of-speech.jpg"
pubDate: 2025-03-17
series: Linters
title: "Why I'd Write a Linter in TypeScript"
---

import girlRunningWithWetCanvas from "~/assets/blog/girl-running-with-wet-canvas.jpg";
import freedomFromWant from "~/assets/blog/freedom-from-want.jpg";
import freedomOfSpeech from "~/assets/blog/freedom-of-speech-tall.jpg";
import LabeledImage from "~/components/blog/mdx/LabeledImage.astro";

It's an exciting time for web dev tooling.
2024 continued 2023's big trend of web tooling was rewriting existing tooling in [Rust](https://www.rust-lang.org), while 2025 saw [TypeScript announce a rewrite in Go](https://devblogs.microsoft.com/typescript/typescript-native-port/).

Web developer linters today are effectively split into two archetypes:

- JavaScript core (i.e. [ESLint](https://eslint.io)): with community plugins for TypeScript and other common needs
- Native speed core (i.e. [Biome](https://biomejs.dev) and [Oxlint](https://oxc.rs/docs/guide/usage/linter)): typically with first party plugins for those needs

From just headlines you'd think the next mainstream web linter should also be written in native code.
But I don't think that's the right direction.
I believe:

- The linter for an ecosystem should be written in a flavor of its primary language.
- Splitting a linter's language bifurcates the lint ecosystem and harms approachability.
- JavaScript-speed lint rules backed by native speed parsing and type information are more than fast enough for the majority of real-world usage scenarios.
- Lint rules should be TypeScript-first for JavaScript and TypeScript files by default.

I'd like to explain what those points mean, how they're different from the other linter archetypes, and their benefits.

<LabeledImage
	alt="Normal Rockwell's 'Freedom of Speech': a working man standing up in a seated crowd in suits and looking up stoically, about to speak."
	description="I know everybody wants to rewrite the web dev tooling world in Go and Rust. But hear me out, there are times when the benefits might not be as great as you'd think."
	original="https://en.wikipedia.org/wiki/Freedom_of_Speech_%28painting%29#/media/File:%22Freedom_of_Speech%22_-_NARA_-_513536.jpg"
	src={freedomOfSpeech}
/>

## 1️⃣ TypeScript Over Native Speed Languages

Native speed source code (Go, Rust, ...) brings significant performance improvements to JIT speed source code (JavaScript/TypeScript).
But authoring lint rules in the same runtime language of the code they analyze brings strong benefits around _developer_ and _ecosystem_ compatibility.

I'm not saying native speed linters such as Biome or Oxlint shouldn't exist or that you shouldn't use them.
Those are fantastic projects run by excellent teams, and they serve a real use case of ultra-fast tooling.

I'm saying I think there should _also_ be a JavaScript/TypeScript-first linter - and here's why.

### Motivator: Developer Compatibility

One of the best parts of modern linters is the ability for teams to write custom rules in their linter.
Lint rules are self-contained exercises in using "AST"s (Abstract Syntax Trees): the core building block of many web development tools.
The linter is an important entry point for developers to enter the wonderful world of language tooling.

Using an alternative language for a linter gates development to developers who are familiar with both languages.
Most developers writing TypeScript, a high-level memory-managed VM language, aren't also familiar -let alone confident- with lower level languages such as Go or Rust.

Furthermore, most professional teams developing web applications don't include many low-level-familiar developers (if any).
There may be a few Go developers familiar with the backend if the product stack includes Go.
But finding multiple developers on a TypeScript-focused team who are proficient enough with Go or Rust to write lint rules in them is uncommon.

> ✋ Please don't reply guy me about how _your_ team has _plenty_ of Go/Rust/Zig/etc. devs.
> Plenty of teams do.
> The problem is that most web teams _don't_.

Most developers -especially ["dark matter"](https://www.hanselman.com/blog/dark-matter-developers-the-unseen-99) developers- work in roughly one paradigm.
In my experiences on web platform teams, it was hard enough to get developers interested in _any_ custom lint rules, let alone ones written in a completely different paradigm than their day-to-day work.
I'd like to avoid any additional "barriers to entry" if at all possible.

> **The linter for an ecosystem should be written in a flavor of its primary language**.

#### Avoiding Multiple Core Languages

Today's native code linters are starting to allow third-party rules to be written easily in JavaScript/TypeScript [^biome-discussion-plugins-biome-2] [^deno-blog-lint-plugins].
That solves some of the language approachability issues.
Teams can write lint rules in the web language they're comfortable in.
This is good!

But:

> **Splitting a linter's language bifurcates the lint ecosystem and harms approachability.**

If a linter doesn't enforce a single primary language, its rule rule implementations will fracture across multiple languages.
Any developer who is only confident in one of those languages will not be able to contribute to a significant portion of the linter's ecosystem.

A linter's own rules generally establish best practices and serve as a technical reference.
Not so if userland rules are written in a different language.

I want users of my linter to be able to look at the source code of the linter's rules.
They should be helped towards the same _"oh, this isn't so unapproachable!"_ realization I had many years ago that got me into working on linting.
Splitting out rules into a completely separate language harms the linter's ability to onboard new contributors.

### Motivator: Ecosystem Compatibility

Most libraries for any ecosystem are written exclusively for that ecosystem's one primary runtime.
Third-party lint rules, especially those specific to a framework, often end up using those utilities.

Writing JavaScript/TypeScript lint rules in JavaScript/TypeScript guarantees the lint rules have access to the same set of utilities userland code uses.
Having to cross the bridge between JavaScript/TypeScript and Rust for a JavaScript/TypeScript would be an added tax to development and maintenance.

Consider again the common case of a web development team.
Suppose their TypeScript design system tokens and utilities are referenced in custom lint rules -- a common need.
Lint rules written in Rust would need some interoperability layer to import and use those tokens, assuming those tokens match Rust paradigms.
Lint rules written in TypeScript can import those tokens directly and stay within a single language's way of thinking.

Bridges between native code and JavaScript/TypeScript do exist.
Node.js FFI and WASM interop layers in particular are steadily getting better over time.
But the _conceptual_ overhead of jumping between language paradigms makes me lean strongly away from multi-language lint rules.

### Drawback: Performance

Native speed linters are absurdly fast at untyped linting.
They can achieve incredible performance because they're written in languages optimized for performant low-level tooling.
A linter that executes wholly in Node.js "JIT" (Just In Time) compiling speed cannot achieve even close to the same speeds.

Typed linting will always be roughly as slow as type checking [^tseslint-docs-slow-typescript-types].
Typed linting is a very complex operation that is fundamentally much slower than pure AST parsing and crawling.
Now that TypeScript is being ported to Go, 90% of that bottleneck is going to go away.

> 👉 See my post on the TypeScript bottleneck: [Why Typed Linting Needs TypeScript Today](/blog/why-typed-linting-needs-typescript-today).

I think slower lint speeds is the biggest drawback of a JavaScript-speed linter.
However, I think the performance downsides are significantly less many think:

1. ESLint performance is not a fair comparison to native speed linters
2. JavaScript excels at high-level logic
3. Linting a full repository is not the most important metric (partial re-lints are)

Let's dig into those points.

#### ESLint Performance is a Straw Man Fallacy

Many of the teams excited about their performance improvements from switching off ESLint were "holding it wrong" to begin with.
ESLint with typed linting is notoriously difficult to configure and properly debug at scale [^tseslint-issue-document-debug-env-vars-debugging-performance].
I've seen plenty of projects from very capable team experiencing, say, 2x slowdowns from entries covered in the [typescript-eslint Performance Troubleshooting & FAQs](https://typescript-eslint.io/troubleshooting/typed-linting/performance) [^cloudflare-workerd-pr-remove-eslint-prettier-config].

Furthermore, ESLint is not optimized for typed linting performance.
Its caching does not support cross-file information [^tseslint-docs-can-i-use-eslint-cache] and there are clear engine-level optimizations yet to be made [^eslint-rfc-parsing-session-objects].
Explorations in [TSSLint](https://github.com/johnsoncodehk/tsslint), another JIT speed linter, show a very lovely performance speedup compared to ESLint [^tsslint-performance].
Heck, [Node.js compile caching](https://nodejs.org/en/blog/release/v22.8.0#new-js-api-for-compile-cache) was only recently added to ESLint [^eslint-pr-using-nodejs-compile-cache].

You can't make a fair judgement against linters written in a JavaScript flavor by pointing at ESLint.
ESLint is not the fastest linter running JavaScript on Node.js anymore.
Judging all JavaScript-speed linters based on ESLint is a [straw man fallacy](https://en.wikipedia.org/wiki/Straw_man).

#### Linting A Full Repository Is Not the Most Important Metric (Partial Re-Lints Are)

Most performance comparisons of linters compare time to lint a full repository.
I don't think that's the right metric to focus on.
You almost never lint a full repository in a single lint run.
The two most common, relevant usage scenarios for linting are:

- Linting a single file as you edit it
- Linting in CI to to catch lint failures in changed files and their dependents

Consider a linter that analyzes file imports and exports -à la [Knip](https://knip.dev)- to detect which files are affected by a change.
Those files are typically a small percentage of source code in real-world changes.

Typed linting often takes up 70% or more of the lint time for a file [^tseslint-pr-typescript-estree-jump-table].
I believe that once we have a linter that can intelligently re-lint changed files using native speed type information, that will become the most common relevant performance comparison for linting.

#### JavaScript Excels at High-Level Logic

Many of the performance gains from rewriting in native speed languages come from low-level optimizations to creating data structures in memory.
TypeScript's Go rewrite, for example, benefits greatly from Go's memory layout and allocation models [^typescript-go-discussion-why-go].

Those concerns are much less impactful for the areas of code that operate on already-created data structures.
Once an AST with type information has been generated for a file, the actual work done by a linter is relatively small.

To prove the point, check out this this linting performance comparison: [lint-rule-jit-on-parsing-native-speed](https://github.com/JoshuaKGoldberg/lint-rule-jit-on-parsing-native-speed).
It parses 100-line files containing assorted syntax using [swc](https://swc.rs) then passes the result to a rudimentary JavaScript lint rule.
Its performance on my M1 Mac Studio is about 90 milliseconds to lint 100 files, or about 350 milliseconds to lint 1,000 files.

> **JavaScript-speed lint rules backed by native speed parsing and type information are more than fast enough for the majority of real-world usage scenarios.**

<LabeledImage
	alt="Normal Rockwell's 'Girl Running with Wet Canvas': a schoolgirl in red running while holding wet painting supplies and a painting of a white tree on tan grass. She holds a paintbrush in her mouth and has a determined look on her face."
	description="JavaScript performance can run faster than you think in many use cases."
	original="https://www.wikiart.org/en/norman-rockwell/girl-running-with-wet-canvas"
	src={girlRunningWithWetCanvas}
/>

## 2️⃣ TypeScript Over JavaScript for ASTs

ESLint core uses the community-specified "[ESTree](https://eslint.org/docs/latest/use/core-concepts/glossary#estree)" AST format.
ESTree is different and separate from the TypeScript AST.
ESLint itself has no concept of TypeScript's AST, let alone type information, in its core architecture or parsing [^eslint-issue-make-rules-typescript-syntax-aware].

> 💡 See [ASTs and typescript-eslint](https://typescript-eslint.io/blog/asts-and-typescript-eslint) for how typescript-eslint builds on top of the ESLint ESTree base.

Sticking with the community ESTree spec is an intentional decision by the ESLint TSC (Technical Steering Committee) made for several reasons:

- ESLint is positioned as a JavaScript-first linter, with any flavor such as Flow or TypeScript fitting into its plugin model
- ESLint wants to avoid a core runtime dependency on any tool it can't easily control
- ESLint wants to use itself as "[dogfooding](https://en.wikipedia.org/wiki/Eating_your_own_dog_food)", particularly for its parser and rules

ESLint's decision makes sense given those goals and priorities for ESLint.

My personal vision for a linter is different from ESLint's.
I want to value _optimizing for the majority_ more highly than _ideological pureness_.
With that priority weighting my conclusion is:

> **Lint rules should be TypeScript-first for JavaScript and TypeScript files by default.**

TypeScript support and type information would be built-in to my linter.
It'd of course have support for non-script languages (JSON, Markdown, etc.) and allow plugging in non-TypeScript flavors of JavaScript ([Ezno](https://github.com/kaleidawave/ezno), [Flow](https://flow.org), etc.).
But I want to optimize the architecture to be as straightforward as possible for full typed linting.

Let me explain why.

### TypeScript Is Essential For Typed Linting

> 💡 Unfamiliar with typed linting or why Lint rules needs it?
> SeeTyped Linting: The Most Powerful TypeScript Linting Ever](https://typescript-eslint.io/blog/typed-linting).

TypeScript's type checking APIs must be provided AST nodes generated by TypeScript [^typescript-ast-nodes-for-types-caveats].
Specifically, [TypeScript's Type Checker APIs](https://github.com/microsoft/TypeScript/wiki/Using-the-Compiler-API#type-checker-apis) are made available by the TypeScript "Program" objects that roughly represent an application being type checked using a TSConfig.
Those Program APIs work in terms of TypeScript AST nodes.

That means type-informed linters have two strategies to choose from:

- Dual tree: use a different AST format, but allow some way of creating a TypeScript program and mapping to the equivalent nodes
- TypeScript core: use TypeScript's AST nodes by creating a TypeScript program internally

As I see it, if you're going to be creating a TypeScript tree internally anyway, having an additional tree is conceptually heavyweight.
I'm proposing the _TypeScript core_ strategy to avoid the burden of a _dual tree_ format.

#### Dual Trees Are Inconvenient

The main downside of the dual-tree format is the complication for linter teams and lint rule authors working with TypeScript APIs.
We've written utilities in typescript-eslint to help with common cases [^tseslint-pr-type-checker-wrapper-apis] but the conceptual overhead is painful.
Most nontrivial typed lint rules end up breaking out of those utilities and needing to call to TypeScript APIs that require TypeScript AST nodes.

Ramping teams up on AST concepts, then on type checker APIs, is painful enough.
Now we have to explain why there are _two_ ASTs, and when to use each one?
It's a nightmare.

We've also had to dedicate a bit of time for every TypeScript AST change to update the typescript-eslint parser's node conversion logic.
We sometimes have bugs when types mismatch between trees or our conversion logic doesn't represent relationships correctly.
The maintenance tax for dual-tree conversion isn't horribly painful, but it's non-zero.

We should be making the acts of writing lint rules and adding type awareness to lint rules as streamlined as possible.
Especially given my desire for built-in type awareness, I think the tradeoff of having to depend on TypeScript is worth it.

### Not a Motivator: Dual Tree Performance

I've seen a lot of developers express performance concerns about how typescript-eslint's dual tree strategy has to create two ASTs.
Although thinking about performance is good, I've never seen tree parsing or conversion be a relevant performance bottleneck once typed linting is involved.
The space and time used for a project's typed linting are always exponentially larger than those of a dual tree parse-and-convert.

[Brad Zacher](https://github.com/bradzacher) tried out optimizing typescript-eslint's parser to use a more efficient AST converter [^tseslint-issue-conversion-logic-jump-table].
The results there were that even with a 10% reduction in _conversion_ time, the net reduction in _overall_ time was only ~0.2% [^tseslint-pr-typescript-estree-jump-table].
That was because lint rules themselves take up most lint timing asking TypeScript for type information.

The cost of parsing and converting into a dual tree structure is not a significant performance factor when linting with type information.

### Drawback: ESLint Ecosystem Compatibility

One downside of using the TypeScript AST shape for lint rules is losing interoperability with existing ESLint rules.
[ESTree](https://github.com/estree/estree)'s AST structure is fundamentally different from TypeScript's.
Any rule written for ESLint and ESTree would have to be rewritten in TypeScript's AST.
That's a lot of work, especially as rules update.
[TSLint](https://palantir.github.io/tslint) was killed in part to avoid this very same burden!

I think this drawback is not as severe as it used to be.
ESLint's ecosystem has matured over the last few years:

- The act of writing rules is much better documented now than it was when TSLint was being killed.
- The rate of growth for new plugins has slowed: we're not experimenting as much with new rules and plugins as we were a few years ago.
- The recent ESLint "flat config" launch is both taking a lot of time away from rule shakeups and helping show how many community plugins aren't actively changing very much [^eslint-issue-tracking-flat-config-support].

For experimental evidence, see the [Biome Linter rules from other sources](https://github.com/biomejs/biome/discussions/3) and [Oxlint Rules](https://oxc.rs/docs/guide/usage/linter/rules.html) pages showing _hundreds_ of community rules each linter has implemented.
I think that progress is great evidence that the drawbacks of rewriting lint rules in a new AST structure can be outweighed by other advantages.

## What It Would Take To Convince Me

I'm open to learning I'm wrong about this.
If a native speed linter can show me that it can provide the same developer and ecosystem compatibility as a TypeScript-first linter, I'd be happy to change my mind.

But, in order to do so, I think we'd need to first see a fundamental shift in how developers learn web code.
The only way I can see the pedagogical benefits of writing rules in JavaScript or TypeScript being overcome is if the majority of developers are already familiar with a native speed language such as Go or Rust.

That would be a huge shift in the web ecosystem.
I don't see it happening any time soon.
I think the web ecosystem is going to continue to stay JavaScript/TypeScript-first for the foreseeable future.

## More Thoughts

I've put a lot of thought into how linting plays into the web ecosystem.
You can read more of my blog posts to see other aspects of it:

- [Why Typed Linting Needs TypeScript Today](/blog/why-typed-linting-needs-typescript-today)
- [Rust-Based JavaScript Linters: Fast, But No Typed Linting Right Now](/blog/rust-based-javascript-linters-fast-but-no-typed-linting-right-now)
- [The Blurry Line Between Formatting and Style](/blog/the-blurry-line-between-formatting-and-style)

I'm drafting a much deeper dive into what I would want in a new linter.
You can preview it on [Blog post: 'If I wrote a linter'](https://github.com/JoshuaKGoldberg/dot-com/pull/284).

Separately, Nolan Lawson's [Why I’m skeptical of rewriting JavaScript tools in “faster” languages](https://nolanlawson.com/2024/10/20/why-im-skeptical-of-rewriting-javascript-tools-in-faster-languages/) is a great post on the subject of native speed rewrites.
It digs into the differences in runtime performance, contributions, and debuggability.

Nothing I've said here or any in any of those blog posts is set in stone.
If you have thoughts here, I'd love to talk with you.
Let me know!

<LabeledImage
	alt="Normal Rockwell's 'Freedom From Want': a family excitedly talking as the matriarch and patriarch are about to place a Thanksgiving turkey on the table."
	description="I want web dev tooling, and linting in particular, to bring people together. Granted, sometimes it's to complain about the lint rules they hate. But sometimes it's for nice things like the bugs linters catch or best practices they educate on..."
	original="https://en.wikipedia.org/wiki/Norman_Rockwell#/media/File:%22Freedom_From_Want%22_-_NARA_-_513539.jpg"
	src={freedomFromWant}
/>

Thanks to Dimitri Mitropoulos from [Michigan TypeScript](https://michigantypescript.com) for reviewing and giving excellent feedback on this post.

[^biome-discussion-plugins-biome-2]: [Announcement: Plugins are coming to Biome 2.0](https://github.com/biomejs/biome/discussions/4428)

[^biome-issue-type-aware-linter]: [biomejs/biome#3187 ☂️ Type-aware linter](https://github.com/biomejs/biome/issues/3187)

[^cloudflare-workerd-pr-remove-eslint-prettier-config]: [cloudflare/workerd#3320 remove eslint-prettier-config](https://github.com/cloudflare/workerd/pull/3320)

[^deno-blog-lint-plugins]: [Deno 2.2: OpenTelemetry, Lint Plugins, node:sqlite > JavaScript plugin API](https://deno.com/blog/v2.2#javascript-plugin-api)

[^deno-issue-type-aware-lints]: [denoland/deno_lint#1138 Type-aware lints](https://github.com/denoland/deno_lint/issues/1138)

[^eslint-issue-make-rules-typescript-syntax-aware]:
    [eslint/eslint#19173 Change Request: Make rules TypeScript syntax-aware](https://github.com/eslint/eslint/issues/19173).
    Some core ESLint rules may respond to TypeScript-specific nodes and node properties appearing in the AST, but ESLint itself does not produce those properties.
    It relies on a third-party parser such as `@typescript-eslint/parser`.

[^eslint-issue-tracking-flat-config-support]: [eslint/eslint#18093 📈 Tracking: Flat Config support](https://github.com/eslint/eslint/issues/18093)

[^eslint-pr-using-nodejs-compile-cache]: [eslint/eslint#19012 perf: using Node.js compile cache](https://github.com/eslint/eslint/pull/19012)

[^eslint-rfc-parsing-session-objects]: [eslint/rfcs#102 feat: parsing session objects](https://github.com/eslint/rfcs/pull/102)

[^oxlint-type-aware-linting]: [oxc-project/oxc#3105](https://github.com/oxc-project/oxc/issues/3105)

[^tseslint-docs-can-i-use-eslint-cache]: [typescript-eslint.io > Troubleshooting & FAQs > ESLint > Can I use ESLint's `--cache` with typescript-eslint?](https://typescript-eslint.io/troubleshooting/faqs/eslint/#can-i-use-eslints---cache-with-typescript-eslint)

[^tseslint-docs-slow-typescript-types]: [typescript-eslint.io > Troubleshooting & FAQs > Typed Linting > Performance > Slow TypeScript Types](https://typescript-eslint.io/troubleshooting/typed-linting/performance#slow-typescript-types)

[^tseslint-issue-conversion-logic-jump-table]: [typescript-eslint/typescript-eslint#6149 Repo: investigate switching core TS->ESTree conversion logic from a "switch/case" to a "jump table" for performance improvements](https://github.com/typescript-eslint/typescript-eslint/issues/6149)

[^tseslint-issue-document-debug-env-vars-debugging-performance]: [typescript-eslint/typescript-eslint#8189 Docs: Document using debug package env variables to debug performance](https://github.com/typescript-eslint/typescript-eslint/issues/8189)

[^tseslint-issue-document-timing-stats-debugging-performance]: [typescript-eslint/typescript-eslint#9135 Docs: add an FAQ section about eslint TIMING/`--stats` and type-aware rules being misleading](https://github.com/typescript-eslint/typescript-eslint/issues/9135)

[^tseslint-issue-typescript-go]: [typescript-eslint/typescript-eslint#10940 Enhancement: Use TypeScript's Go port (tsgo / typescript-go) for type information](https://github.com/typescript-eslint/typescript-eslint/issues/10940)

[^tseslint-pr-type-checker-wrapper-apis]: [typescript-eslint/typescript-eslint#6404 feat(typescript-estree): add type checker wrapper APIs to ParserServicesWithTypeInformation](https://github.com/typescript-eslint/typescript-eslint/pull/6404)

[^tseslint-pr-typescript-estree-jump-table]: [typescript-eslint/typescript-eslint#6371 feat(typescript-estree): use a jump table instead of switch/case for conversion logic](https://github.com/typescript-eslint/typescript-eslint/pull/6371)

[^tsslint-performance]:
    [johnsoncodehk/tsslint#10 Why is this config not correct? (issue comment)](https://github.com/johnsoncodehk/tsslint/issues/10#issuecomment-2461035385).
    Note that johnsoncodehk is not trying to make direct performance comparisons between TSSLint and other linters yet.
    The comment should serve only as a proof of concept.

[^typescript-ast-nodes-for-types-caveats]:
    It is possible that the upcoming typescript-go APIs will take in source code locations rather than AST nodes themselves.
    However, both the information retrieved by those APIs and common community tooling built around TypeScript types are centered on TypeScript AST nodes.
    I think it's a safe bet that the TypeScript AST and projects will at the very least be the primary _mental model_ of typed linting for the foreseeable future.

[^typescript-go-discussion-why-go]: [microsoft/typescript-go#411 Why Go?](https://github.com/microsoft/typescript-go/discussions/411)
