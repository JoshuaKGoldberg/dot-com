---
description: "Explaining the potential of a TypeScript-first linter strategy that blends the compatibility benefits of ESLint with the simpler execution model of Biome or Oxlint."
image:
  alt: "The face of the man from Normal Rockwell's 'Freedom of Speech': standing up and looking up stoically, about to speak."
  src: "~/assets/blog/freedom-of-speech.jpg"
pubDate: 2025-03-18
series: Linters
title: "Why I'd Write a Linter in TypeScript"
---

It's an exciting time for web linting.
ESLint's flat config is stable in production and most popular community plugins support it now.
2024 continued 2023's big trend of web tooling was rewriting existing tooling in [Rust](https://www.rust-lang.org), while 2025 saw [TypeScript announce a rewrite in Go](https://devblogs.microsoft.com/typescript/typescript-native-port/).

The Node.js linting world is effectively split into two archetypes:

- JavaScript core (i.e. [ESLint](https://eslint.io)): with community plugins for TypeScript and other common needs
- Native speed core (i.e. [Biome](https://biomejs.dev) and [Oxlint](https://oxc.rs/docs/guide/usage/linter)): typically with first party plugins for those needs

Both are exciting and fascinating growth cycles.
From just headlines you'd think the next mainstream web linter should also be written in native code.
But I don't think that's the right direction.
I want _lint rules written in TypeScript_ with _first-class support for typed linting_.

I'd like to explain what that means, how it's different from the other archetypes, and its benefits.

## 1️⃣ TypeScript Over Native Speed Languages

I believe:

> **The linter for an ecosystem should be written in a flavor of its primary language**.

Although other runtimes are faster than JavaScript's, there are strong benefits around _developer_ and _ecosystem_ compatibility to sticking with JavaScript or TypeScript for a web linter.

I'm not saying native speed linters such as Biome or Oxlint shouldn't exist or that you shouldn't use them.
Those are fantastic projects run by excellent teams, and they serve a real use case of ultra-fast tooling.

I'm saying I think there should _also_ be a JavaScript/TypeScript-first linter - and here's why.

### Motivator: Developer Compatibility

One of the best parts of modern linters is the ability for teams to write custom rules in their linter.
Lint rules are self-contained exercises in using "AST"s (Abstract Syntax Trees): the core building block of many web development tools.
The linter is an important entry point for developers to enter the wonderful world of language tooling.

Using an alternative language for a linter gates development to developers who are familiar with both languages.
Most developers writing TypeScript, a high-level memory-managed VM language, aren't also familiar -let alone confident- with lower level languages such as Go or Rust.

Furthermore, most professional teams developing web applications don't include many low-level-familiar developers (if any).
There may be a few Go developers familiar with the backend if the product stack includes Go.
But finding multiple developers on a TypeScript-focused team who are proficient enough with Go or Rust to write lint rules in them is generally a pleasant surprise rather than a common norm.

> ✋ Please don't reply guy me about how _your_ team has _plenty_ of Go/Rust/Zig/etc. devs.
> Plenty of teams do.
> The problem is that most web teams _don't_.

Most developers -especially ["dark matter"](https://www.hanselman.com/blog/dark-matter-developers-the-unseen-99) developers- work in roughly one paradigm.
In my experiences on web platform teams, it was hard enough to get developers interested in _any_ custom lint rules, let alone ones written in a completely different paradigm than their day-to-day work.
I'd like to avoid any additional "barriers to entry" if at all possible.

#### Motivator: Avoiding Multiple Core Languages

Today's native code linters are starting to allow third-party rules to be written easily in JavaScript/TypeScript.
That solves some of the language approachability issues.
Teams can write lint rules in the web language they're comfortable in.
This is good!

But:

> **Splitting a linter's language bifurcates the lint ecosystem and harms approachability.**

If a linter doesn't enforce a single primary language, its rule rule implementations will fracture across multiple languages.
Any developer who is only confident in one of those languages will not be able to contribute to a significant portion of the linter's ecosystem.

A linter's own rules generally establish best practices and serve as a technical reference.
Not so if userland rules are written in a different language.

I want users of my linter to be able to look at the source code of the linter's rules.
They should be helped towards the same _"oh, this isn't so unapproachable!"_ realization I had many years ago that got me into working on linting.
Splitting out rules into a completely separate language harms the linter's ability to onboard new contributors.

### Motivator: Ecosystem Compatibility

Most libraries for any ecosystem are written exclusively for that ecosystem's one primary runtime.
Third-party lint rules, especially those specific to a framework, often end up using those utilities.

Writing JavaScript/TypeScript lint rules in JavaScript/TypeScript guarantees the lint rules have access to the same set of utilities userland code uses.
Having to cross the bridge between JavaScript/TypeScript and Rust for a JavaScript/TypeScript would be an added tax to development and maintenance.

Consider again the common case of a web development team.
Suppose their TypeScript design system tokens and utilities are referenced in custom lint rules -- a common need.
Lint rules written in Rust would need some interoperability layer to import and use those tokens, assuming those tokens match Rust paradigms.
Lint rules written in TypeScript can import those tokens directly and stay within a single language's way of thinking.

Bridges between native code and JavaScript/TypeScript do exist.
Node.js FFI and WASM interop layers in particular are steadily getting better over time.
But the _conceptual_ overhead of jumping between language paradigms makes me lean strongly away from multi-language lint rules.

### Not a Motivator: Type Information

> 💡 Unfamiliar with typed linting?
> See [Typed Linting: The Most Powerful TypeScript Linting Ever](https://typescript-eslint.io/blog/typed-linting).

I've previously blogged on type information and native code linters: [Rust-Based JavaScript Linters: Fast, But No Typed Linting Right Now](/blog/rust-based-javascript-linters-fast-but-no-typed-linting-right-now).
No native code linter today fully supports [linting with type information](https://typescript-eslint.io/getting-started/typed-linting).

That's a transient concern.
Those linters will eventually support typed linting.
They're already working on it [^biome-type-aware-linter] [^deno-type-aware-lints] [^oxlint-type-aware-linting] .
Lack of typed linting support is not a long-term motivator against writing linters in native code.

For me, it's the drawbacks on _developer_ and _ecosystem_ compatibility that push wanting a linter written in JavaScript or TypeScript.

### Drawback: Performance

Native speed linters are absurdly fast at untyped linting.
They can achieve incredible performance because they're written in languages optimized for performant low-level tooling.
A linter that executes wholly in Node.js "JIT" (Just In Time) compiling speed cannot achieve even close to the same speeds.

Typed linting will always be roughly as slow as type checking [^tseslint-docs-slow-typescript-types].
Typed linting is a very complex operation that is fundamentally much slower than pure AST parsing and crawling.
Now that TypeScript is being ported to Go, 90% of that bottleneck is going to go away.

> 👉 See my post on the TypeScript bottleneck: [Why Typed Linting Needs TypeScript Today](/blog/why-typed-linting-needs-typescript-today).

I think slower lint speeds is the biggest drawback of a JIT-speed linter.
However, I think the performance downsides are significantly less many think:

1. ESLint performance is not a fair comparison to native speed linters
2. Speed of linting an entire project should not be a common use case

Let's dig into those points.

#### ESLint Performance is a Straw Man Fallacy

Many of the teams excited about their performance improvements from switching off ESLint were "holding it wrong" to begin with.
ESLint with typed linting is notoriously difficult to configure and properly debug at scale [^tseslint-issue-document-debug-env-vars-debugging-performance].
I've seen plenty of projects from very capable team experiencing, say, 2x slowdowns from entries covered in the [typescript-eslint Performance Troubleshooting & FAQs](https://typescript-eslint.io/troubleshooting/typed-linting/performance) [^cloudflare-workerd-pr-remove-eslint-prettier-config].

Furthermore, ESLint is not optimized for typed linting performance.
Its caching does not support cross-file information [^tseslint-docs-can-i-use-eslint-cache] and there are clear engine-level optimizations yet to be made [^eslint-rfc-parsing-session-objects].
Explorations in [TSSLint](https://github.com/johnsoncodehk/tsslint), another JIT speed linter, show a very lovely performance speedup compared to ESLint [^tsslint-performance].
Heck, [Node.js compile caching](https://nodejs.org/en/blog/release/v22.8.0#new-js-api-for-compile-cache) was only recently added to ESLint [^eslint-pr-using-nodejs-compile-cache].

You can't make a fair judgement against linters written in a JavaScript flavor by pointing at ESLint.
ESLint is not the fastest linter running JavaScript on Node.js anymore.
Judging all JavaScript-speed linters based on ESLint is a [straw man fallacy](https://en.wikipedia.org/wiki/Straw_man).

#### Linting A Full Repository is Not the Most Important Metric

Most performance comparisons of linters compare time to lint a full repository.
I don't think that's the right metric to focus on.
You almost never lint a full repository in a single lint run.
The two most common, relevant usage scenarios for linting are:

- Linting a single file as you edit it
- Linting in CI to to catch lint failures in changed files and their dependents

Consider a linter that analyzes file imports and exports à la [Knip](https://knip.dev) to detect which files are affected by a change.
That linter could lint only those files, which in the majority of real-world changes, is typically a small percentage of a repository.
The parts of linting managed by the JIT-speed linter would be a fraction of the work spent on generating type information.

I set up a performance comparison to test that claim: [TODO](TODO).
It parses a repository of 1,000 files with either Babel (JIT speed) or swc (native speed) then runs a rudimentary JavaScript lint rule on 10 of those files' ASTs.
The Babel parser takes ~TODO seconds on my M1 Mac Studio, whereas the swc parser and JavaScript lint rule takes ~TODO seconds.

JIT-speed lint rules backed by native speed parsing and type information are plenty fast enough for the majority of real-world usage scenarios.

## 2️⃣ TypeScript Over JavaScript for ASTs

ESLint core uses the "[ESTree](https://eslint.org/docs/latest/use/core-concepts/glossary#estree)" AST format.
ESTree is a community specification that is different from the TypeScript AST.
ESLint itself has no concept of TypeScript in its core architecture or lint rules.

> 💡 See [ASTs and typescript-eslint](https://typescript-eslint.io/blog/asts-and-typescript-eslint) for how typescript-eslint builds on top of the ESLint ESTree base.

Sticking with the community ESTree spec is an intentional decision by the ESLint TSC (Technical Steering Committee) made for several reasons:

- ESLint is positioned as a JavaScript-first linter, with any flavor such as Flow or TypeScript fitting into its plugin model
- ESLint wants to avoid a core runtime dependency on any tool it can't easily control
- ESLint wants to use itself as "[dogfooding](https://en.wikipedia.org/wiki/Eating_your_own_dog_food)", particularly for its parser and rules

ESLint's decision makes sense given those goals and priorities for ESLint.

My personal vision for a linter is different from ESLint's.
I want to value _optimizing for the majority_ more highly than _ideological pureness_.
With that priority weighting my conclusion is:

> A web linter should be **TypeScript-first for its JavaScript and TypeScript files by default**.

TypeScript support and type information would be built-in to my linter.
It'd of course have support for non-script languages (JSON, Markdown, etc.) and allow plugging in non-TypeScript flavors of JavaScript ([Ezno](https://github.com/kaleidawave/ezno), [Flow](https://flow.org), etc.).
But I want to optimize the architecture to be as straightforward as possible for full typed linting.

Let me explain why.

### TypeScript Nodes Are Essential For TypeScript Types

TypeScript's type checking APIs must be provided AST nodes generated by TypeScript [^typescript-ast-nodes-for-types-caveats].
Specifically, [TypeScript's Type Checker APIs](https://github.com/microsoft/TypeScript/wiki/Using-the-Compiler-API#type-checker-apis) are made available by the TypeScript "Program" objects that roughly represent an application being type checked using a TSConfig.
If a linter wants type checking with TypeScript today, it needs to create a TypeScript Program and use nodes created by that Program's representation of source files.

That means type-informed linters have two strategies to choose from:

- Dual tree: use a different AST format, but allow some way of creating a TypeScript program and mapping to the equivalent nodes
- TypeScript core: use TypeScript's AST nodes by creating a TypeScript program internally

As I see it, if you're going to be creating a TypeScript tree internally anyway, having an additional tree is conceptually heavyweight.
I'm proposing the _TypeScript core_ strategy to avoid the burden of a _dual tree_ format.

#### Motivator: Dual Trees Are Inconvenient

The main downside of the dual-tree format is the complication for linter teams and lint rule authors working with TypeScript APIs.
We've written utilities in typescript-eslint to help with common cases [^tseslint-pr-type-checker-wrapper-apis] but the conceptual overhead is painful.
Most nontrivial typed lint rules end up breaking out of those utilities and needing to call to TypeScript APIs that require TypeScript AST nodes.

Ramping teams up on AST concepts, then on type checker APIs, is painful enough.
Now we have to explain why there are _two_ ASTs, and when to use each one?
It's a nightmare.

We've also had to dedicate a bit of time for every TypeScript AST change to update the typescript-eslint parser's node conversion logic.
We sometimes have bugs when types mismatch between trees or our conversion logic doesn't represent relationships correctly.
The maintenance tax for dual-tree conversion isn't horribly painful, but it's non-zero.

We should be making the acts of writing lint rules and adding type awareness to lint rules as streamlined as possible.
Especially given my desire for built-in type awareness, I think the tradeoff of having to depend on TypeScript is worth it.

### Not a Motivator: Dual Tree Performance

I've seen a lot of developers express performance concerns about how typescript-eslint's dual tree strategy has to create two ASTs.
Although thinking about performance is good, I've never seen tree parsing or conversion be a relevant performance bottleneck once typed linting is involved.
The space and time used for a project's typed linting are always exponentially larger than those of a dual tree parse-and-convert.

For example, [Brad Zacher](https://github.com/bradzacher) tried out optimizing typescript-eslint's parser to use a more efficient AST converter [^tseslint-issue-conversion-logic-jump-table].
The results there were that even with a 10% reduction in _conversion_ time, the net reduction in _overall_ time was only ~0.2% [^tseslint-pr-typescript-estree-jump-table].
That was because lint rules themselves take up most lint timing asking TypeScript for type information.

The cost of parsing and converting into a dual tree structure is not a significant performance factor when linting with type information.

### Drawback: ESLint Ecosystem Compatibility

One downside of using the TypeScript AST shape for lint rules is losing interoperability with existing ESLint rules.
[ESTree](https://github.com/estree/estree)'s AST structure is fundamentally different from TypeScript's.
Any rule written for ESLint and ESTree would have to be rewritten in TypeScript's AST.
That's a lot of work, especially as rules update.
[TSLint](https://palantir.github.io/tslint) was killed in part to avoid this very same burden!

I think this drawback is important, but not as pressing as it used to be.
ESLint's ecosystem has matured over the last few years.
The act of writing rules is much better documented now than it was when TSLint was being killed.
The recent ESLint "flat config" launch is both taking a lot of time away from rule shakeups and helping show how many community plugins aren't actively changing very much [^eslint-issue-tracking-flat-config-support].

For experimental evidence, see the [Biome Linter rules from other sources](https://github.com/biomejs/biome/discussions/3) and [Oxlint Rules](https://oxc.rs/docs/guide/usage/linter/rules.html) pages showing _hundreds_ of community rules each linter has implemented.
I think that progress is great evidence that the drawbacks of rewriting lint rules in a new AST structure can be outweighed by other advantages.

## What It Would Take To Convince Me

I'm open to learning I'm wrong about this.
If a native speed linter can show me that it can provide the same developer and ecosystem compatibility as a TypeScript-first linter, I'd be happy to change my mind.

But, in order to do so, I think we'd need to see a fundamental shift in how developers learn web code.
The only way I can see the pedagogical benefits of writing rules in JavaScript or TypeScript being overcome is if the majority of developers are already familiar with a native speed language such as Go or Rust.

That would be a huge shift in the web ecosystem.
I don't see it happening any time soon.
I think the web ecosystem is going to continue to stay JavaScript/TypeScript-first for the foreseeable future.

## More Thoughts

I've put a lot of thought into how linting plays into the web ecosystem.
You can read more of my blog posts to see other aspects of it:

- [Why Typed Linting Needs TypeScript Today](/blog/why-typed-linting-needs-typescript-today)
- [Rust-Based JavaScript Linters: Fast, But No Typed Linting Right Now](/blog/rust-based-javascript-linters-fast-but-no-typed-linting-right-now)
- [The Blurry Line Between Formatting and Style](/blog/the-blurry-line-between-formatting-and-style)

I'm drafting a much deeper dive into what I would want in a new linter.
You can preview it on [Blog post: 'If I wrote a linter'](https://github.com/JoshuaKGoldberg/dot-com/pull/284).

Separately, Nolan Lawson's [Why I’m skeptical of rewriting JavaScript tools in “faster” languages](https://nolanlawson.com/2024/10/20/why-im-skeptical-of-rewriting-javascript-tools-in-faster-languages/) is a great post on the subject of native speed rewrites.
It digs into the differences in runtime performance, contributions, and debuggability.

Nothing I've said here or any in any of those blog posts is set in stone.
If you have thoughts here, I'd love to talk with you.
Let me know!

[^biome-type-aware-linter]: [biomejs/biome#3187 ☂️ Type-aware linter](https://github.com/biomejs/biome/issues/3187)

[^cloudflare-workerd-pr-remove-eslint-prettier-config]: [cloudflare/workerd#3320 remove eslint-prettier-config](https://github.com/cloudflare/workerd/pull/3320)

[^deno-type-aware-lints]: [denoland/deno_lint#1138 Type-aware lints](https://github.com/denoland/deno_lint/issues/1138)

[^eslint-issue-tracking-flat-config-support]: [eslint/eslint#18093 📈 Tracking: Flat Config support](https://github.com/eslint/eslint/issues/18093)

[^eslint-pr-using-nodejs-compile-cache]: [eslint/eslint#19012 perf: using Node.js compile cache](https://github.com/eslint/eslint/pull/19012)

[^eslint-rfc-parsing-session-objects]: [eslint/rfcs#102 feat: parsing session objects](https://github.com/eslint/rfcs/pull/102)

[^oxlint-type-aware-linting]: [oxc-project/oxc#3105](https://github.com/oxc-project/oxc/issues/3105)

[^tseslint-issue-conversion-logic-jump-table]: [typescript-eslint/typescript-eslint#6149 Repo: investigate switching core TS->ESTree conversion logic from a "switch/case" to a "jump table" for performance improvements](https://github.com/typescript-eslint/typescript-eslint/issues/6149)

[^tseslint-issue-document-debug-env-vars-debugging-performance]: [typescript-eslint/typescript-eslint#8189 Docs: Document using debug package env variables to debug performance](https://github.com/typescript-eslint/typescript-eslint/issues/8189)

[^tseslint-issue-document-timing-stats-debugging-performance]: [typescript-eslint/typescript-eslint#9135 Docs: add an FAQ section about eslint TIMING/`--stats` and type-aware rules being misleading](https://github.com/typescript-eslint/typescript-eslint/issues/9135)

[^tseslint-pr-type-checker-wrapper-apis]: [typescript-eslint/typescript-eslint#6404 feat(typescript-estree): add type checker wrapper APIs to ParserServicesWithTypeInformation](https://github.com/typescript-eslint/typescript-eslint/pull/6404)

[^tseslint-pr-typescript-estree-jump-table]: [typescript-eslint/typescript-eslint#6371 feat(typescript-estree): use a jump table instead of switch/case for conversion logic](https://github.com/typescript-eslint/typescript-eslint/pull/6371)

[^tsslint-performance]:
    [johnsoncodehk/tsslint#10 Why is this config not correct? (issue comment)](https://github.com/johnsoncodehk/tsslint/issues/10#issuecomment-2461035385).
    Note that johnsoncodehk is not trying to make direct performance comparisons between TSSLint and other linters yet.
    The comment should serve only as a proof of concept.

[^typescript-ast-nodes-for-types-caveats]:
    It is possible that the upcoming typescript-go APIs will take in source code locations rather than AST nodes themselves.
    However, both the information retrieved by those APIs and common community tooling built around TypeScript types are centered on TypeScript AST nodes.
    I think it's a safe bet that the TypeScript AST and projects will at the very least be the primary _mental model_ of typed linting for the foreseeable future.

[^tseslint-docs-can-i-use-eslint-cache]: [typescript-eslint.io > Troubleshooting & FAQs > ESLint > Can I use ESLint's `--cache` with typescript-eslint?](https://typescript-eslint.io/troubleshooting/faqs/eslint/#can-i-use-eslints---cache-with-typescript-eslint)

[^tseslint-docs-slow-typescript-types]: [typescript-eslint.io > Troubleshooting & FAQs > Typed Linting > Performance > Slow TypeScript Types](https://typescript-eslint.io/troubleshooting/typed-linting/performance#slow-typescript-types)
