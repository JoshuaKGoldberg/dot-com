---
pubDate: 2025-05-04 10:00 GMT
description: "This how I would architect a modern linter from scratch: focusing on built-in TypeScript support, a straightforward rule development experience, and deduplicating tooling."
image:
  alt: "Tevye from Fiddler on the Roof TODO_ACTIVITY"
  src: "~/assets/blog/sisyphus.jpg"
title: "If I Wrote a Linter, Part 1: Architecture"
---

import {
	Tabs,
	TabsList,
	TabsTab,
	TabsPanel,
} from "accessible-astro-components";

import tevyeDancing from "~/assets/blog/tevye-dancing.webp";
import LabeledImage from "~/components/blog/mdx/LabeledImage.astro";
import LabeledVideo from "~/components/blog/mdx/LabeledVideo.astro";

Today's web linters are great.
[ESLint](https://eslint.org) is robust and has a huge ecosystem of plugins and configs.
Newer native speed linters such as [Biome](https://biomejs.dev), [`deno lint`](https://lint.deno.land), and [Oxlint](https://github.com/oxc-project/oxc) are fast and easy to set up with their own burgeoning ecosystems.

I've been working on TypeScript linting for almost a decade.
I started contributing to [TSLint](https://palantir.github.io/tslint) community projects in 2016 and am now a number of the [typescript-eslint](https://github.com/typescript-eslint/typescript-eslint) and [ESLint](https://github.com/eslint/eslint) teams.
Based on those years of various linters, I've collected a large set of design ideas that I want to see in a new web linter.

I see a linter that is **fast by default**, **powerful upon request**, and **straightforward to configure**.
This post is how I would architect it.

<LabeledImage
	alt="Tevye from Fiddler on the Roof snapping his hands back and forth in a dance."
	description="Tevye from Fiddler on the Roof enjoying linting his code with a very strict configuration."
	original="https://giphy.com/gifs/classic-movies-musicals-fiddler-on-the-roof-xULW8PseQFMgq8Bums"
	src={tevyeDancing}
/>

> ðŸ’¡ This post is the first in a series:
>
> <br />
>
> - ðŸ‘‰ [Part 1: Architecture](/blog/if-i-wrote-a-linter-part-1-architecture)
> - Part 2: Developer Experience _(coming soon)_
> - Part 3: Ecosystem _(coming soon)_
> - Part 4: Summary _(coming soon)_

## Hybrid Core

I want the fantastic performance benefits of recent native speed linters.
I also want the developer approachability benefits of writing all rules -not just select userland plugins- in TypeScript.

My linter would have a **hybrid core**:

- _File intake_ and _type information_ would be native speed, for performance
- _Coordinating logic_ and _rules_ would be TypeScript, to stay approachable for developers

[Hybrid Linters: The Best of Both Worlds](/blog/hybrid-linters-the-best-of-both-worlds) covers this in more detail.

# Type Aware, Always

[typescript-eslint's Typed Linting](https://typescript-eslint.io/getting-started/typed-linting) is the most powerful JavaScript/TypeScript linting in common use today.
Lint rules that use type information are significantly more capable than traditional, AST-only rules.
Many popular lint rules have ended up either dependent on typed linting or having to deal with known bugs or feature gaps without typed linting. [^eslint-plugin-react-hooks-detection-typed-linting] [^eslint-plugin-vitest-valid-type-type-checking]

But, typed linting is not an easy feature for many users right now.
Even if you do understand typed linting, enabling it requires additional linter config setup.
Avoiding typed linting's common configuration pitfalls [^tseslint-troubleshooting-typed-linting] is not a straightforward task.

The divide between untyped core rules and _only some_ typed rules is painful for the ecosystem:

- Core rules are less powerful than they could be
- Plugins have to choose between being fast and easy to set up vs. slower and type-aware
- ESLint core isn't structured for cross-file linting, so there are known typed linting performance woes [^eslint-rfc-feat-parsing-session-objects] and blatant editor extension bugs [^vscode-eslint-cross-file-information]

On the other hand, given this hypothetical linter's hybrid core, typed linting would be significantly faster and much easier to set up.
Removing typed linting's downsides means the linter could make type information always available for all rules.
That would simplify the linting story:

- Core rules don't need to be duplicated by plugins to add in typed linting support
- Plugins don't have to depend on an ad-hoc non-core project for type information
- The core linter architecture can be optimized for type-checked linting performance

For this always-type-aware-world, I envision projects effectively always having some equivalent of [typescript-eslint's new Project Service](https://typescript-eslint.io/blog/announcing-typescript-eslint-v8#project-service) enabled.
And because the core can optimize for it, it wouldn't have performance issues from including "out-of-project" files.
All files could be linted with type information!
What a wonderful world that would be.

## TypeScript For Type Awareness

TypeScript is the only tool that can provide full TypeScript type information for JavaScript or TypeScript code.
AST-only lookups fall apart quickly once you have anything but the most straightforward of projects.
See [Why Typed Linting Needs TypeScript Today](/blog/why-typed-linting-needs-typescript-today).

Typed linting's performance with TypeScript 5.x is troublesome today even for projects that configure it correctly.
It still feels slow even on linters optimized for it such as [TSSLint](https://github.com/johnsoncodehk/tsslint).

I'm optimistic the _10x performance improvements_ from [TypeScript's Go port](https://devblogs.microsoft.com/typescript/typescript-native-port) will mostly solve the performance issue.
I believe a linter that uses the 10x faster TypeScript in Go _and_ has built-in support for typed linting would make typed linting well worth its performance cuts.

### TypeScript FFI

If a Node.js linter that wants to call to native Go code, it has roughly three common options:

- [FFI (Foreign Function Interface)](https://en.wikipedia.org/wiki/Foreign_function_interface): running TypeScript's Go functions within the linting process
- [IPC (Inter-Process Communication)](https://en.wikipedia.org/wiki/Inter-process_communication): creating a separate TypeScript Go process
- [WebAssembly](https://en.wikipedia.org/wiki/WebAssembly): compiling TypeScript's Go code to WebAssembly to be run in the linter process

WebAssembly would be ideal -- except Go's output is still suboptimal for this use case [^go-performance-of-wasm] [^typescript-go-wasm-performance].

IPC's isolated processes are much generally easier to work with.
But, IPC is slower than FFI because it has to serialize and deserialize data between the two processes.

For Go in particular, FFI is tricky because Go functions work in a single shared memory space.
Users running the linter would be stuck with whatever version of TypeScript and Go is bundled with the linter.

Until Go's WebAssembly story is more favorable, I would want to use FFI for as fast linting type information as possible.
If users want to use a different set of Go code, they can always spawn a dedicated process for the linter itself.

## Built-In TypeScript Support

ESLint is one of the few common modern JavaScript utilities that doesn't support parsing TypeScript syntax out-of-the-box.
Although core rules react well to parsed TypeScript syntax now [^eslint-issue-change-request-make-core-rules-typescript-syntax-aware], your configuration must use typescript-eslint to actually parse that syntax.

Also inconvenient is the inability of core ESLint rules to understand TypeScript types or concepts.
That's led to the concept of "extension rules" in typescript-eslint [^tseslint-extension-rules]: rules that replace built-in rules.
Extension rules are confusing for users and inconvenient to work with for both maintainers and users.

I'm excited that ESLint is rethinking its TypeScript support [^rethinking-typescript-support-in-eslint].
Hopefully, once the ESLint rewrite [^eslint-discussion-rewrite] comes out, we'll be able to declutter userland configs and deduplicate the extension rules.

If I wrote a linter, it would support TypeScript natively.
No additional packages or "extension" rules.
The core parser would be TypeScript's, and core rules would understand TypeScript syntax and types.

### TypeScript's AST

ESLint's AST representation is [ESTree](https://github.com/estree/estree).
`@typescript-eslint/parser` works by parsing code using TypeScript's parser into TypeScript's AST, then recursively creating a "TSESTree" (ESTree + TypeScript nodes) structure roughly adhering to ESTree from that.

We do this because both of those ASTs are necessary in ESLint's model:

- ESTree: means lint rules have no dependency on the corporate-backed TypeScript -- they are compatible with ESLint core
  - One of the main downsides of TSLint being based on TypeScript's AST was having to rewrite every ESLint/ESTree-based lint rule for TSLint
- TypeScript's: must be used for nodes passed to TypeScript APIs, most notably for typed linting

The main downside of this dual-tree format is the complication for linter teams and lint rule authors working with TypeScript APIs.
On the typescript-eslint team, we must dedicate time for every TypeScript AST change to update node conversion logic.
For lint rule authors, having to convert TSESTree nodes to their TS counterparts before passing to TypeScript APIs is an annoyance.
We've written utilities to help with common cases [^tseslint-pr-type-checker-wrapper-apis] but the conceptual overhead alone is bad enough.

As much as I like the goal of remaining ESTree/JavaScript-oriented in JavaScript linters, this dual-tree overhead is awful.
TypeScript is the only popular type-oriented language in web code [^flow-blog-clarity-on-direction].
I want to make the acts of writing lint rules as streamlined as possible.
If I wrote a linter, lint rules for JavaScript and TypeScript code would use TypeScript's AST.

## Embeddable by Design

Right now, most web projects that employ both linting and type checking run them separately in CI.
Projects typically either run them in parallel across two workflows or in series within the same workflow.
That's inefficient.
You either use an extra workflow or take roughly twice as long to run.

The root problem is that projects typically don't connect the type information generated by TypeScript to typed linting in ESLint.
Projects effectively run a full type-check twice: once with `tsc` and once with typed linting.

Other folks have already started working on this problem.
[typescript-eslint-language-service](https://github.com/Quramy/typescript-eslint-language-service) is a direction I'd already like to explore in working more closely with typescript-eslint.
[TSSLint](https://github.com/johnsoncodehk/tsslint) is a recent project that does a great job of integrating with tsserver.

If I wrote a linter, it would have native support for embedding within TypeScript as a [language service plugin](https://www.typescriptlang.org/tsconfig/#plugins).
I'm not sure yet how this would look -does this happen client-side and CI? only CI?- but I think the potential to deduplicate type information computation in CI is tantalizing.

## Core Common Languages

Linting is useful for more than just JavaScript and TypeScript.
ESLint plugins exist for basically every language that web repositories use.
I think a modern web linter should encourage applying the same developer assistance and quality checks to all the languages in a project.

If I wrote a linter, it would support all languages that are common to both backend and frontend web projects:

- JavaScript and TypeScript
- JSON
- Markdown
- YML

This means the core linter architecture would be completely agnostic of any specific language.
It would look like the newer ESLint architecture where each language is its own plugin [^eslint-discussion-rewrite] [^eslint-rfc-language-plugins].

## Formatting Coordination

One of the biggest reasons users move to Biome or Oxc is that those tools perform both _formatting_ and _linting_ with a single devDependency and configuration file.
In doing so, they provide a much easier setup and maintenance story, as well as eliminate many common ESLint misconfigurations that lead to performance issues [^tseslint-troubleshooting-performance-stylistic] [^tseslint-troubleshooting-performance-prettier] [^tseslint-troubleshooting-performance-import].

I think that's a great idea.
I still believe _lint rules_ should not be used for formatting [^post-stop-using-eslint-for-formatting] [^post-the-blurry-line-between-formatting-and-style].
But I've found that if I want to format a file type, there's practically always a linting plugin I'd want for it too.
If both the formatter and linter are running on the same set of files, deduplicating _coordination_ into the linter makes sense to me.

If I wrote a linter, it would provide "postlint" hooks for tasks like running a formatter [^eslint-issue-change-request-add-a-concept-of-postlint-hooks].
By default it would at least run a formatter on files after linting them.
You wouldn't need to include formatting-specific configuration files in your repository at all.
Formatting would be wholly coordinated by the linter.

## Up Next

I find this post's architecture ideas exhilarating and terrifying.
They're a huge departure from the current state of linting, even stepping in the opposite direction of other linters in many cases.
But I think the advantages have the potential to be huge:

- Combining the performance of native speed with the joy of TypeScript-first lint rules
- Reducing the amount of language plugins from >=2 to 1 for all common projects
- Shrinking the config files, devDependencies, scripts for formatting+linting from >=3 to 1
- Deduplicating type information computation in CI from >=2 job to 1

Over the next week or two, I'll post more about the developer experience and ecosystem points of this proposed new linter.
I hope you're look forward to them as much as I am!

> ðŸ’¡ This post is the first in a series:
>
> <br />
>
> - ðŸ‘‰ [Part 1: Architecture](/blog/if-i-wrote-a-linter-part-1-architecture)
> - Part 2: Developer Experience _(coming soon)_
> - Part 3: Ecosystem _(coming soon)_
> - Part 4: Summary _(coming soon)_

# References

[^eslint-discussion-rewrite]: [eslint/eslint#16557 Complete rewrite of ESLint](https://github.com/eslint/eslint/discussions/16557)

[^eslint-issue-change-request-add-a-concept-of-postlint-hooks]: [Change Request: Add a concept of "postlint" hooks, such as for running a formatter](https://github.com/eslint/eslint/issues/19171)

[^eslint-issue-change-request-make-core-rules-typescript-syntax-aware]: [eslint/eslint#19173 Change Request: Make core rules TypeScript syntax-aware](https://github.com/eslint/eslint/issues/19173)

[^eslint-plugin-react-hooks-detection-typed-linting]: [facebook/react#25065 Bug: Eslint hooks returned by factory functions not linted](https://github.com/facebook/react/issues/25065)

[^eslint-plugin-vitest-valid-type-type-checking]: [vitest-dev/eslint-plugin-vitest#251 valid-type: use type checking to determine test name type?](https://github.com/vitest-dev/eslint-plugin-vitest/issues/251)

[^eslint-rfc-feat-parsing-session-objects]: [eslint/rfcs#102 feat: parsing session objects](https://github.com/eslint/rfcs/pull/102)

[^eslint-rfc-language-plugins]: [eslint/rfcs#99 feat: ESLint Language Plugins](https://github.com/eslint/rfcs/pull/99)

[^flow-blog-clarity-on-direction]: [Clarity on Flow's Direction and Open Source Engagement](https://medium.com/flow-type/clarity-on-flows-direction-and-open-source-engagement-e721a4eb4d8b)

[^go-performance-of-wasm]: [golang/go#65440 cmd/compile: performance of go wasm is very poor](https://github.com/golang/go/issues/65440)

[^post-stop-using-eslint-for-formatting]: [Configuring ESLint, Prettier, and TypeScript Together > STOP USING ESLINT FOR FORMATTING](/blog/configuring-eslint-prettier-and-typescript-together/#stop-using-eslint-for-formatting)

[^post-the-blurry-line-between-formatting-and-style]: [The Blurry Line Between Formatting and Style](/blog/the-blurry-line-between-formatting-and-style)

[^rethinking-typescript-support-in-eslint]: [eslint/eslint#18830 Rethinking TypeScript support in ESLint](https://github.com/eslint/eslint/discussions/18830)

[^tseslint-extension-rules]: [typescript-eslint > Rules > Extension Rules](https://typescript-eslint.io/rules/#extension-rules)

[^tseslint-pr-type-checker-wrapper-apis]: [typescript-eslint/typescript-eslint#6404 feat(typescript-estree): add type checker wrapper APIs to ParserServicesWithTypeInformation](https://github.com/typescript-eslint/typescript-eslint/pull/6404)

[^tseslint-troubleshooting-performance-import]: [typescript-eslint Troubleshooting & FAQs > Typed Linting > Performance > `eslint-plugin-import`](https://typescript-eslint.io/troubleshooting/typed-linting/performance#eslint-plugin-import)

[^tseslint-troubleshooting-performance-prettier]: [typescript-eslint Troubleshooting & FAQs > Typed Linting > Performance > `eslint-plugin-prettier`](https://typescript-eslint.io/troubleshooting/typed-linting/performance#eslint-plugin-prettier)

[^tseslint-troubleshooting-performance-stylistic]: [typescript-eslint Troubleshooting & FAQs > Typed Linting > Performance > `@stylistic/ts/indent` and other stylistic rules rules](https://typescript-eslint.io/troubleshooting/typed-linting/performance#stylistictsindent-and-other-stylistic-rules-rules)

[^tseslint-troubleshooting-typed-linting]: [typescript-eslint > Troubleshooting & FAQs > Typed Linting](https://typescript-eslint.io/troubleshooting/typed-linting)

[^typescript-go-wasm-performance]: [microsoft/typescript-go#514 Go WASM performance](https://github.com/microsoft/typescript-go/discussions/514)

[^vscode-eslint-cross-file-information]: [microsoft/vscode-eslint#1774 ESLint does not re-compute cross-file information on file changes](https://github.com/microsoft/vscode-eslint/issues/1774)
