---
description: "Explaining why the speed gains from Rust linters aren't comparable to the full feature set of typescript-eslint."
image:
  alt: Josh smiling on stage and giving a presentation showing the "Type Checking React (v2)" from the linked slides.
  src: react-miami-me-speaking.jpg
pubDate: 2024-01-07
tags: [
	"biome",
	"deno lint",
	"eslint",
	"linting",
	"oxc",
	"rslint",
	"typed linting",
	"typescript-eslint",
]
title: "Rust-Based JavaScript Linters Lack Typed Linting Right Now"
---

One of 2023's biggest trends for web tooling was rewriting existing tooling in [Rust](https://www.rust-lang.org).
Rust is a wonderful programming language that allows for shockingly fast binaries that still interop well with other web tools courtesy of WebAssembly.
The speedups seen in tools such as [swc](https://swc.rs) and [Turbopack](https://turbo.build/pack) are very exciting for fast development experiences.

[Biome](https://biomejs.dev), [`deno lint`](https://lint.deno.land), [oxc](https://github.com/oxc-project/oxc), and [RSLint](https://rslint.org) are all projects that include at least a JavaScript/TypeScript linter written in Rust.
The idea of a linter that runs at Rust (native code) speed rather than JavaScript (JIT script) speed is quite appealing for developers frustrated with slow lint times.

But!
It's a misconception to think that Rust-based linters are a complete and total replacement for [ESLint](https://eslint.org) today.
There are always pros and cons to switching tooling.
In this case, the pros are much less than many have noted, while the cons are much more significant.

## Recap: Type-Checked Linting

Traditionally, lint rules in linters such as ESLint only have visibility into one source code file at a time.
This makes them fast and theoretically cacheable and parallelizable.

[typescript-eslint](https://typescript-eslint.io) introduces the concept of [linting with type information](https://typescript-eslint.io/linting/typed-linting).
By calling to TypeScript's type checking APIs, lint rules can make much more informed decisions on code based on types informed by potentially any other file in your project.

Type-checked lint rules can be significantly more capable than traditional lint rules.
For example:

- [`@typescript-eslint/await-thenable`](https://typescript-eslint.io/rules/await-thenable) disallows `await`s unnecessarily used on non-Thenable (non-Promise) values
- [`@typescript-eslint/no-floating-promises`](https://typescript-eslint.io/rules/no-floating-promises) lets you know if you create a Promise and forget to handle it safely
- [`@typescript-eslint/no-for-in-array`](https://typescript-eslint.io/rules/no-for-in-array): flags accidental unsafe `for...in` iterations over arrays (instead of `for...of`)

Each of those rules is only practically useful when they can use type information to determine when to report issues.
Without type information, they wouldn't be able to understand the type of any value imported from another module.

### Type-Checked Linting Performance

The main downside of type-checked linting is performance.
Lint rules are now blocked on calling to an API such as TypeScript's, which generally need to read all files to see which ones impact types of any other file.
That means linting performance will often be strictly worse than that of running `tsc` on your entire project.

We're actively working on this in typescript-eslint.
Our [Performance Troubleshooting](https://typescript-eslint.io/linting/troubleshooting/performance-troubleshooting) docs have some suggestions, and we're very hopeful that our [`EXPERIMENTAL_useProjectService` option](https://typescript-eslint.io/packages/parser/#experimental_useprojectservice) will land as stable in 2024.
But even if that option works perfectly then type-checked linting will by design be orders of magnitude slower than traditional linting.

Our experience has been that the benefits of type-checked linting almost always far outweigh the drawbacks of slower performance.
Most of the time, when we've seen projects with slow type-checked linting, the root cause was either a misconfiguration of typescript-eslint or [slow TypeScript types](https://github.com/microsoft/TypeScript/wiki/Performance).

## Rust-Based Linters and Type Checking

**No Rust-based linter has integrated with TypeScript's type checking APIs yet**.
That means no Rust-based linter is a full replacement for ESLint + typescript-eslint.

I'm not saying you shouldn't use a Rust-based linter: if you don't want any of the type-checked lint rules, then sure, switching over is great.
But I strongly recommend you look through at least the [recommended type-checked rules in typescript-eslint](https://typescript-eslint.io/rules/?=recommended-typeInformation) to understand what you're missing first.

### Integrating Type-Checked Linting and Rust-Based Linters

Right now, TypeScript is the only tool that can reliably provide type-checked linting for TypeScript code.
TypeScript is written in TypeScript, so its type checking runs at JavaScript speed.

In order to work with type checking, a Rust linter would have to either:

- Take the performance hit of calling to TypeScript's JavaScript-speed type-checking APIs
- Reimplement TypeScript's APIs in a native speed language
- Speed Up TypeScript's APIs to native speed

#### Option: Slowing Down to JavaScript Speed

The performance hit option would likely slow the linters down to the point where they have no noticeable performance advantage compared to ESLint.
ðŸ‘Ž

That being said, if any native speed linter wants to do this, we in typescript-eslint would love to help.
The [`@typescript-eslint/parser`](https://typescript-eslint.io/packages/parser) and [`@typescript-eslint/typescript-estree`](https://typescript-eslint.io/packages/typescript-estree) Node.js APIs are open source and as well documented as we've thought to write.
We'd be happy to work with anybody who wants to use them, including spinning out standalone packages if that'd be useful.

#### Option: Reimplementing TypeScript at Native Speed

Reimplementing TypeScript at native speed is a tantalizing prospect for TypeScript users in general, not just linters.
I know of three attempts: two actively under development ([Ezno](https://github.com/kaleidawave/ezno) and [`stc`](https://stc.dudy.dev)) and one older one ([TypeRunner](https://github.com/marcj/TypeRunner)).
Both projects are very early stage and not likely to become production ready for a very long time.

Keep in mind that re-implementing TypeScript in a new language is a herculean task.
TypeScript's type checking has to deal with bizarrely complex edge cases around generic types, covariance, contravariance, and other terms most of us shudder to hear.

> ðŸ’¡ See [Ryan Cavanaugh's _Let's Make a Generic Inference Algorithm_ TypeScript Congress 2023 talk](https://portal.gitnation.org/contents/lets-make-a-generic-inference-algorithm) for an example of what TypeScript has to deal with.

TypeScript is also a funded development team with contributions from its own programming language specialists and community contributors.
Keeping up with its new versions is a Sisyphean task for any re-implementation.
As impressive as Ezno and `stc` are, their long-term feasibility as standalone projects is precarious.

> ðŸ’¡ See [Matt Pocock's _Rewriting TypeScript in Rust? You'd have to be..._](https://www.totaltypescript.com/rewriting-typescript-in-rust) for more discussion with `stc`'s Donny.

#### Option: Boosting TypeScript's APIs to Native Speed

I think a more viable long-term option would be to find a way to get TypeScript's type checker to run at native speed.
There are a couple possibilities:

- Writing a tool that transpiles its source to a faster language such as Go or Rust
- Pre-compiling and optimizing TypeScript like a binary

Both of those options are difficult and will take some time to land.
[Transpiling the checker to Go](https://kdy1.dev/2022-1-26-porting-tsc-to-go) was the original aim of what became `stc` before the [the project switched to the Rust re-implementation](https://kdy1.dev/2022-10-27-open-sourcing-stc#heading-ill-switch-back-to-the-rust-version).

[Node.js user land snapshots](https://nodejs.org/en/blog/release/v18.8.0#bootstrap-implement-run-time-user-land-snapshots-via---build-snapshot-and---snapshot-blob) are mentioned in TypeScript's [Ideas for faster cold compiler start-up issue](https://github.com/microsoft/TypeScript/issues/25658) in the context of startup times.
For the context of typed linting, aggressively JITing code ahead of time might be marginally useful too.
The [Hermes engine](https://hermesengine.dev) has some interesting build-time precompilation too.

Though, TypeScript itself isn't architected for native code.
It assumes a runtime with built-in garbage collection, mutable objects, and other performance paper cuts
I suspect the biggest gains might be from rearchitecting TypeScript to be more performance-friendly:

- Restricting global type augmentations to be more parallelization-friendly
- Changing the way its checker runs to avoid those paper cuts

Both avenues would be very difficult to implement and cause breaking changes in TypeScript's APIs.
Neither is likely to happen any time soon.

## Performance Comparisons

I'm not going to show you a performance comparison of Rust-based linters vs. ESLint vs. ESLint with typescript-eslint.
The comparison would be misleading: until Rust-based linters achieve feature parity with typed linting rules, they benefit in comparisons from having to run significantly less work.
And given how many different avenues we have yet to flesh out in running type linting rules with a native speed linter, we have near-zero idea what that performance would look like.

> ðŸ’¡ When evaluating performance comparisons, always make sure the comparisons are on comparable behavior.
> Don't trust any metric you don't understand the contents of.

## In Conclusion

Rust-based JavaScript/TypeScript linters such as [Biome](https://biomejs.dev), [`deno lint`](https://lint.deno.land), [oxc](https://github.com/oxc-project/oxc), and [RSLint](https://rslint.org) are fantastically fast projects.
But that speed comes with a serious feature gap compared to [ESLint](https://eslint.org) + [typescript-eslint](https://typescript-eslint.io)'s [type-checked lint rules](https://typescript-eslint.io/linting/typed-linting).
You should understand what you're missing when you switch from one to the other.

Rust-based linters may eventually be able to get the benefits of type-checked linting at native speed code.
But it's going to be a very long time until that's feasible.
