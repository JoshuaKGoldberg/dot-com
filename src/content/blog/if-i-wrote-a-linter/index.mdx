---
pubDate: 2025-04-02
description: "Why I'd write a TypeScript linter in TypeScript, build in TypeScript syntax and type awareness always, and other musings on the state of web linting in 2025."
image:
  alt: "Tevye from Fiddler on the Roof TODO_ACTIVITY"
  src: "~/assets/blog/sisyphus.jpg"
title: "If I Wrote a Linter"
---

import tevyeDancing from "~/assets/blog/tevye-dancing.webp";
import LabeledImage from "~/components/blog/mdx/LabeledImage.astro";
import LabeledVideo from "~/components/blog/mdx/LabeledVideo.astro";

> # ðŸ›‘ **THIS IS JUST A DRAFT.**
>
> I need to run it by other developers in the linter ecosystem.
> It might be horribly wrong and it might be horribly misrepresenting reality.
> Please don't take it seriously!

<LabeledImage
	alt="Tevye from Fiddler on the Roof TODO_ACTIVITY"
	description="Tevye from Fiddler on the Roof enjoying linting his code with a very strict configuration."
	original="https://giphy.com/gifs/classic-movies-musicals-fiddler-on-the-roof-xULW8PseQFMgq8Bums"
	src={tevyeDancing}
/>

I've been working on TypeScript linting for a while.
I started contributing to [TSLint](https://palantir.github.io/tslint) community projects in 2016 and am now a number of the [typescript-eslint](https://github.com/typescript-eslint/typescript-eslint) and [ESLint](https://github.com/eslint/eslint) teams.
I've also enjoyed the recent rise of native speed linters such as [Biome](https://biomejs.dev), [`deno lint`](https://lint.deno.land), and [Oxlint](https://github.com/oxc-project/oxc).

But, I have ideas that aren't seen in any existing linter.
I have a vision for a web linter that is **fast by default**, **powerful upon request**, and **straightforward to configure**,
I think it can be done -- here's how and why.

## Core Architecture

This is how I would choose to build a linter in 2025.

### Hybrid Core

I want the fantastic performance benefits of recent native speed linters.
I also the developer approachability benefits of writing all rules -not just select userland plugins- in TypeScript.

My linter would have a **hybrid core**:

- _File intake_ and _type information_ would be native speed, for performance
- _Coordinating logic_ and _rules_ would be TypeScript, to stay approachable for developers

[Hybrid Linters: The Best of Both Worlds](/blog/hybrid-linters-the-best-of-both-worlds) covers this in more detail.

## Type Aware, Always

[typescript-eslint's Typed Linting](https://typescript-eslint.io/getting-started/typed-linting) is the most powerful JavaScript/TypeScript linting in common use today.
Lint rules that use type information are significantly more capable than traditional, AST-only rules.
Many popular lint rules have ended up either dependent on typed linting or having to deal with known bugs or feature gaps without typed linting.[^eslint-plugin-react-hooks-detection-typed-linting][^eslint-plugin-vitest-valid-type-type-checking]

But, typed linting is not an easy feature for many users right now.
The divide between untyped core rules and _only some_ typed rules is painful for the ecosystem:

- Core rules are less powerful than they could be
- Extension rules have to choose between being fast and easy to set up vs. slow and type-aware
- ESLint core isn't structured for cross-file linting, so there are known typed linting performance woes[^rfc-feat-parsing-session-objects] and blatant editor extension bugs[^vscode-eslint-cross-file-information]

Even if you do understand typed linting, you have to go through an additional setup on top of your config's TypeScript configuration.
Setting it up without hitting typed linting's common configuration pitfalls[^tseslint-troubleshooting-typed-linting] is not a straightforward task.

On the other hand, if rules can always assume type awareness, the linting story becomes much simpler:

- Core rules don't need to be duplicated by plugins to add in typed linting support
- Plugins don't have to depend on an ad-hoc non-core project for type information
- The core linter architecture can be optimized for type-checked linting performance

For this always-type-aware-world, I envision projects effectively always having some equivalent of [typescript-eslint's new Project Service](https://typescript-eslint.io/blog/announcing-typescript-eslint-v8#project-service) enabled.
And because the core can optimize for it, it wouldn't have performance issues from including "out-of-project" files.
All files could be linted with type information!
What a wonderful world that would be.

### TypeScript For Type Awareness

TypeScript is the only tool that can provide full TypeScript type information for JavaScript or TypeScript code.
AST-only lookups fall apart quickly once you have anything but the most straightforward of projects.
See [Why Typed Linting Needs TypeScript Today](/blog/why-typed-linting-needs-typescript-today).

Typed linting's performance with TypeScript 5.x is troublesome today even for projects that configure it correctly.
It still feels slow even on linters optimized for it such as [TSSLint](https://github.com/johnsoncodehk/tsslint.

I'm optimistic the _10x performance improvements_ from [TypeScript's Go port](https://devblogs.microsoft.com/typescript/typescript-native-port) will mostly solve the performance issue.
I believe a linter that uses the 10x faster TypeScript in Go _and_ has built-in support for typed linting would make typed linting well worth its performance cuts.

### Built-In TypeScript Support

ESLint is one of the few common modern JavaScript utilities that doesn't support parsing TypeScript syntax out-of-the-box.
Although core rules react well to parsed TypeScript syntax now [^eslint-issue-change-request-make-core-rules-typescript-syntax-aware], your configuration must use typescript-eslint to actually parse that syntax.

Also inconvenient is the inability of core ESLint rules to understand TypeScript types or concepts.
That's led to the concept of "extension rules" in typescript-eslint[^extension-rules]: rules that replace built-in rules.
Extension rules are confusing for users and inconvenient to work with for both maintainers and users.

I'm excited that ESLint is rethinking its TypeScript support[^rethinking-typescript-support-in-eslint].
Hopefully, once the ESLint rewrite comes out, we'll be able to declutter userland configs and deduplicate the extension rules.

If I wrote a linter, it would support TypeScript natively.
No additional packages or "extension" rules.
The core parser would be TypeScript's, and core rules would understand TypeScript syntax and types.

#### Probably TypeScript's AST

ESLint's AST representation is [ESTree](https://github.com/estree/estree).
`@typescript-eslint/parser` works by parsing code using TypeScript's parser into TypeScript's AST, then recursively creating a "TSESTree" (ESTree + TypeScript nodes) structure roughly adhering to ESTree from that.
Every so often, a tooling aficionado will notice this parse-and-convert duplication and suggest removing one of the two trees to improve performance.

First off, the cost of parsing two ASTs out of source code has never been the relevant bottleneck in any linted project I've seen.
Parse time is practically always dwarfed by type-checked linting time[^tseslint-pr-new-eslint-parser-on-swc].
Runtime performance is not a real reason to avoid the parse-and-convert.

Second, both of those ASTs are useful:

- ESTree: means lint rules have no dependency on the corporate-backed TypeScript -- they are compatible with ESLint core
  - One of the main downsides of TSLint being based on TypeScript's AST was having to rewrite every ESLint/ESTree-based lint rule for TSLint
- TypeScript's: must be used for AST nodes passed to TypeScript APIs, most notably for typed linting

The main downside of this dual-tree format is the complication for linter teams and lint rule authors working with TypeScript APIs.
On the typescript-eslint team, we've had to dedicate a bit of time for every TypeScript AST change to update node conversion logic.
For lint rule authors, having to convert TSESTree nodes to their TS counterparts before passing to TypeScript APIs is an annoyance.
We've written utilities to help with common cases[^tseslint-pr-type-checker-wrapper-apis] but the conceptual overhead alone is bad enough.

Now that typed linting is stable in typescript-eslint and Flow is explicitly not targeting competing with TypeScript for public mindshare[^flow-blog-clarity-on-direction], I'm leaning towards preferring a TypeScript AST shape for core.
We should be making the acts of writing lint rules and adding type awareness to lint rules as streamlined as possible.
Especially given my desire for built-in type awareness, I think the tradeoff of having to depend on TypeScript is worth it.

### Embeddable by Design

Right now, most web projects that employ both linting and type checking run them separately in CI.
Projects typically either run them in parallel across two workflows or in series within the same workflow.
That's inefficient.
You either use an extra workflow or take roughly twice as long to run.

The root problem is that projects typically don't connect the type information generated by TypeScript to typed linting in ESLint.
Projects effectively run a full type-check twice: once with `tsc` and once with typed linting.

Other folks have already started working on this problem.
[typescript-eslint-language-service](https://github.com/Quramy/typescript-eslint-language-service) is a direction I'd already like to explore in working more closely with typescript-eslint.
[TSSLint](https://github.com/johnsoncodehk/tsslint) is a recent project that does a great job of integrating with tsserver.

I think my type-first linter would have native support for embedding within TypeScript as a [language service plugin](https://www.typescriptlang.org/tsconfig/#plugins).
I'm not sure yet how exactly this would look -does this happen client-side and CI? only CI?- but I think the potential to deduplicate type information computation in CI is tantalizing.

## User Experience

### Formatting Coordination

One of the biggest reasons users move to Biome or Oxc is that those tools perform both _formatting_ and _linting_ with a single devDependency and configuration file.
In doing so, they provide a much easier setup and maintenance story, as well as eliminate the all-too-easy common ESLint misconfigurations that lead to performance issues [^tseslint-troubleshooting-performance-stylistic][^tseslint-troubleshooting-performance-prettier][^tseslint-troubleshooting-performance-import].

Even better, they can automatically apply formatting after lint rule autofixes and suggestions.
No more running `--fix` and seeing a bunch of bizarrely formatting `{`s and `}`s until you hit save.

My linter would provide hooks "postlint" hooks, such as for running a formatter such as Prettier [^eslint-issue-change-request-add-a-concept-of-postlint-hooks].
This would simplify repository configuration so that you don't also have to have a formatter configuration (e.g. `.prettierrc.json`, `.prettierignore`).

I still believe _lint rules_ should not be used for formatting [^post-stop-using-eslint-for-formatting] [^post-the-blurry-line-between-formatting-and-style].
But built-in automatic formatting after linting is _really nice_.

### Only Errors

All mainstream web linters today allow configuring rules as _errors_ or _warnings_.
In theory, this is straightforward: errors are visualized with red squigglies and fail builds; warnings are visualized with yellow squigglies and don't fail builds.
Warnings are intended to be transient indicators during migrations or when rules aren't certain about issues [^eslint-pr-docs-warn-severity].

In practice, I think the delineation is not worthwhile:

- Using the same red color and terminology for _lint_ errors and _type-checking_ errors is confusing both ideologically and practically.
  I personally tell my VS Code to visualize lint errors with yellow squigglies, to not conflict with red TypeScript squigglies.
- Warnings tend to live forever in codebases, which trains developers to ignore lint reports.
- If a problem can't be determined with certainty, it either should be suppressed using an inline config comment with an explanation, or not turned into a lint rule at all!

In other words, I think warnings are a bad fit for the migration use case.
Tools like [eslint-nibble](https://github.com/IanVS/eslint-nibble) can provide a more comprehensive experience.
Editor features such as [VS Code's `eslint.rules.customizations`](https://github.com/microsoft/vscode-eslint/pull/1164) can now change how rules are visualized.

If I were to write a linter, I would have it so rules can only be turned off or on.
Gradual onboardings of new rules or rule options would be a separately managed feature.
Changing of visuals for specific rules or categories thereof would be separately managed features in editor extensions.

### Strongly Typed Rules

One of my biggest gripes with all existing linter configuration systems today is that _rule options are not type-safe_.
To recap, you specify them as properties an object, where their string key is their plugin name and rule name, and their value is their severity and any options:

```js
{
	"my-plugin/some-rule": ["error", {
		setting: "...",
	}],
}
```

Those string keys have no associated types in config files.
Linters themselves can validate rule options, such as [ESLint's options schemas](https://eslint.org/docs/latest/extend/custom-rules#options-schemas), but those don't translate to TypeScript types.
You don't get editor intellisense while authoring; instead, you have to use [`@eslint/config-inspector`](https://www.npmjs.com/package/@eslint/config-inspector) or run your config to know whether you've mistyped the name of a rule or an option.

I'd love to make a standard plugin creator function that plugin authors are encouraged -even required- to use.
It could take in a set of rules and return some kind of well-typed function.

Vaguely, maybe it'd use a TypeScript-friendly schema validation library such as [Zod](https://zod.dev) and look something like:

```ts
import { createRule, createPlugin } from "@joshuakgoldberg/if-i-wrote-a-linter";
import { z } from "zod";

const someRule = createRule({
	options: {
		option: z.string(),
	},
});

export const myPlugin = createPlugin({
	name: "My Plugin",
	rules: [someRule],
});
```

...and in usage could look something like:

```ts
// linter.config.ts
import { myPlugin } from "@joshuakgoldberg/my-plugin";

[
	{
		rules: myPlugin.rules({
			someRule: {
				option: "...",
			},
		}),
	},
];
```

Under that kind of system, users would receive intellisense as they type plugin rules, and all those settings could be type checked.
Doing so would even coincidentally solve the issue of [plugin namespacing and rule config duplication](https://github.com/eslint/eslint/discussions/17766).
Config values would still be verified at runtime by the schema validation library.

### Strongly Typed Plugin Settings

An even less type-safe part of ESLint's current config system is the [shared `settings` object](https://eslint.org/docs/latest/use/configure/configuration-files#configuring-shared-settings).
You can put whatever you want in there, and any plugin may read from it.

In theory, cross-plugin shared settings can be used for related plugins, while plugin-specific settings are by convention namespaced under their name.
In practice, I don't think I've ever seen a shared setting used across plugins.

I think a settings system more true to how plugins use it would have plugins define their own settings and settings types.

Vaguely, maybe it'd use a TypeScript-friendly schema validation library such as [Zod](https://zod.dev) and look something like:

```ts
import { createPlugin } from "@joshuakgoldberg/if-i-wrote-a-linter";
import { z } from "zod";

export const myPlugin = createPlugin({
	name: "My Plugin",
	rules: [
		// ...
	],
	settings: {
		setting: z.string(),
	},
});
```

...and in usage could look something like:

```ts
// linter.config.ts
import { myPlugin } from "@joshuakgoldberg/my-plugin";

[
	{
		plugins: [
			myPlugin({
				setting: "...",
			}),
		],
	},
];
```

As with rules, allowing plugins to define their own settings types would help with the config authoring experience.
It would also newly allow shared settings to be validated by both type-checking and the core linter.
Doing so means plugins can be more confident in defining settings and changing them over time as needed.

### Strongly Typed Configuration Files

I think there are roughly two classifications of linter configs in common use today:

- Direct JSON ([`biome.json`](https://biomejs.dev/linter/#configuration), [Deno](https://docs.deno.com/runtime/fundamentals/configuration/#linting), [Oxlint](https://oxc.rs/docs/guide/usage/linter#configuration-file))
- Nuanced JS (ESLint: [`.eslintrc.js` (deprecated)](https://eslint.org/docs/latest/use/configure/configuration-files-deprecated), [`eslint.config.js`](https://eslint.org/docs/latest/use/configure/configuration-files))

Direct JSON is a nice and straightforward "walled garden" that shines in small projects.
But I don't think it scales well.
The user experience of typing config files isn't great if you're not using a custom editor extension to get JSON intellisense.

Nuanced JS configurations from ESLint, on the other hand, are "just JavaScript" and so utilize native module importing for plugins, global variables, and shared configurations.
That's great for understandability and simplifying the plugin loading model.
ESLint's flat config is a huge step forward from the confusing `overrides` model of ESLint's legacy configs.

But, I ESLint's flat config has learned the hard way what nuances trip people up this far outside the "walled garden" of pure JSON:

- Because all config entries are just JavaScript objects, there's no way to lint only the user's own config entries [^eslint-issue-change-request-report-unnecessary-config-overrides]
- Directory relativity becomes confusing when nested configs `import` from a higher-up config [^eslint-issue-change-request-inherit-flat-configs-from-root]
- `ignores` is not very intuitive right now [^stackoverflow-parsing-error-was-not-found-by-the-project-service-but-ive-ignored-these-file] [^tseslint-discord-help-eslint-not-ignoring-js-files]
- Plugins' shared configs being able to set file matches and other settings besides rules adds complexity to configs that use multiple plugins

I think one flaw of the "raw JavaScript" design of flat config is that you have to understand too much about the config _system_ to be able to read and understand a _config file_.
I'd want a config system that gives you fewer ways to mess up and makes it explicitly clear what each portion of the file does.

I think we could get there by:

- Creating delineated functions or objects to create `ignores` blocks, shared configs, and plugins.
- Having plugins automatically register themselves when their rules are included
- Only allow plugin configs to specify rules and shared rule settings

Here's a rough sketch of what the root monorepo config could like with a config system more akin to a [`tsup.config.ts`](https://tsup.egoist.dev/#using-custom-configuration) or [`vitest.config.ts`](https://vitest.dev/config), but with explicit functions for common operations:

```ts
// if-i-wrote-a-linter.config.ts
import { defineConfig } from "@joshuakgoldberg/if-i-wrote-a-linter";
import { pluginSomeExample } from "@joshuakgoldberg/plugin-some-example";

export default defineConfig({
	files: [
		{
			extends: [
				linter.recommended.logical(),
				linter.recommended.stylistic(),
				pluginSomeExample.recommended({
					setting: true,
				}),
			],
			glob: "**/*.{js,ts}",
			rules: [
				linter.rules({
					someCoreRuleA: false,
					someCoreRuleB: true,
					someCoreRuleC: {
						someSetting: true,
					},
				}),
				pluginSomeExample.rules({
					somePluginRule: true,
				}),
			],
		},
	],
	ignore: ["packages/*/dist/", "generated/"],
	workspaces: ["packages/*"],
});
```

Each `packages/*` workspace directory could define its own config that explicitly indicates its root directory:

```ts
// packages/example/if-i-wrote-a-linter.config.ts
import { defineConfig } from "@joshuakgoldberg/if-i-wrote-a-linter";

export default defineConfig({
	files: [
		{
			glob: "src/**/*.ts",
			rules: [
				linter.rules({
					someCoreRuleD: false,
				}),
			],
		},
	],
	ignore: "lib/",
	root: "../..",
});
```

Those config file sketches are a little more verbose than ESLint flat config.
But they're more explicitly clear on what they do, and can be made much more type-safe using the APIs like `defineConfig()` and `linter.rules()`.
The core linter could then even let users know of any redundant properties passed to a `linter.rules()`, `somePlugin.rules()`, or `somePlugin.settings`.

That config system is just a sketch and I have no way of knowing how its tradeoffs would work in production today.
But I'd really love to see how its tradeoffs are experienced by users.

## Userland Standardization

### Consistent Glossary

Most developers I've talked to do not understand or use the right terms when talking about linting.
Heck, most developers don't want to talk about the linter in the first place -- let alone understand the difference between, say, a config and a plugin.

Many important linting terms have inconsistent usage or even definitions in the wild today.
For example, _"stylistic"_ can alternately refer to:

- [Stylistic (Rule)](https://eslint.org/docs/latest/use/core-concepts/glossary#stylistic-rule): The category of lint rules that enforce _formatting_, naming conventions, or consistent usage of equivalent syntaxes
- [ESLint Stylistic](https://eslint.style): The plugin that ESLint's _formatting_ rules were migrated to, along with a small selection of non-formatting stylistic rules
- [typescript-eslint's stylistic shared configs](https://typescript-eslint.io/users/configs#stylistic), which enforce consistent usage of equivalent syntaxes, as well as general TypeScript best practices that don't impact program logic

...what!?

I work on linters and I have a hard time keeping this all straight.

The [ESLint Glossary](https://eslint.org/docs/latest/use/core-concepts/glossary) is a very good first step towards solidifying terminology.
I would want to go one step further and have a single term and definition for all the linting concepts that authors and/or end users care about.
Doing so would provide authors with the guidance to name their configs, plugins, and rules consistently to each other and the linter core.
Users then would have an easier time navigating the plugin ecosystem and understanding how they all fit together.

### Granular Rule Categories

Over the last decade, the linter community learned the hard way that users need properly categorized shared configs.
If you give everyone one config that mixes _logical_ and _stylistic_ rules the way, say, `eslint-plugin-airbnb` did, users will resent the portions they disagree with and turn away from linting altogether.
Plugins that include both of those broad areas of rules now tend to provide dedicated shared configs for different areas of rules [^jsdoc-granular-flat-typescript-configs] [^typescript-eslint-configs].

Once a consistent glossary exists, its definitions can be used to consistently categorize configs and rules.
Heck, the linter could even provide recommended utilities for generating configs based on rule categories.
I think that'd go a long way towards further standardizing and making clear the ecosystem of plugin rules.
At the very least, it'd help encourage plugin authors to make it easier for users to include only the categories of rules they want from the plugin.

### First Party Templates

## Userland Help

### Thorough Config Initializer

### Thorough Examples

### Thorough FAQs

Full explanation docs for all decisions

### Thorough Troubleshooting Guide

## Community

### First Party Community Repositories

First party built in for what is the current slate of popular plugins

## Features for Developers

### Full Virtual File System

[^tseslint-explore-ts-vfs]

something something linting file permissions

### Rich Cross File Fixes

A linter is in many ways the best codemod platform for many kinds of migrations.
It allows you to define a granular, testable set of migration rules, and then keep them enforced over time so developers don't add regressions.
I've personally used lint rules to great effect in rolling out design system updates, enforcement of best practices, and other niceties.

Unfortunately, the "one file at a time" model all of today's linters doesn't lend itself well to all the operations a codemod might need.
Rules may need to make fixes or suggestions to files other than the one being linted [^eslint-issue-change-request-apply-suggestions-to-other-files].

If I were to write a linter, I would add in a rich system for rule fixes and suggestions:

- The ability to indicate changes to virtual files other than the one being linted
- Other file system operations, such as renames and permissions changes

## Implementation

### Session Objects

Full project context available up front including preprocessors and session object

### Pluggable Architecture and APIs

Pluggable api for embedding in places like typescript, TS, config and biome project

[^eslint-issue-change-request-add-a-concept-of-postlint-hooks]: [Change Request: Add a concept of "postlint" hooks, such as for running a formatter](https://github.com/eslint/eslint/issues/19171)

[^eslint-issue-change-request-apply-suggestions-to-other-files]: [eslint/eslint#17881 Change Request: Provide a way for rules to apply suggestions to other files](https://github.com/eslint/eslint/issues/17881])

[^eslint-issue-change-request-inherit-flat-configs-from-root]: [eslint/eslint#18385 Change Request: Make it easier to inherit flat configs from the repo root](https://github.com/eslint/eslint/issues/18385). [eslint/rfcs#120 feat!: Look Up Config Files From Linted File](https://github.com/eslint/rfcs/pull/120) was accepted to change lookup locations, but there's still a _conceptual_ ambiguity of how one config file's relative paths should work in another config file.

[^eslint-issue-change-request-report-unnecessary-config-overrides]: [eslint/eslint#15476 Change Request: report unnecessary config overrides](https://github.com/eslint/eslint/issues/15476)

[^eslint-issue-change-request-make-core-rules-typescript-syntax-aware]: [eslint/eslint#19173 Change Request: Make core rules TypeScript syntax-aware](https://github.com/eslint/eslint/issues/19173)

[^eslint-plugin-react-hooks-detection-typed-linting]: [facebook/react#25065 Bug: Eslint hooks returned by factory functions not linted](https://github.com/facebook/react/issues/25065)

[^eslint-plugin-vitest-valid-type-type-checking]: [vitest-dev/eslint-plugin-vitest#251 valid-type: use type checking to determine test name type?](https://github.com/vitest-dev/eslint-plugin-vitest/issues/251)

[^eslint-pr-docs-warn-severity]: [eslint/eslint#16696 docs: Add explanation of when to use 'warn' severity](https://github.com/eslint/eslint/issues/16696)

[^extension-rules]: [typescript-eslint > Rules > Extension Rules](https://typescript-eslint.io/rules/#extension-rules)

[^flow-blog-clarity-on-direction]: [Clarity on Flow's Direction and Open Source Engagement](https://medium.com/flow-type/clarity-on-flows-direction-and-open-source-engagement-e721a4eb4d8b)

[^jsdoc-granular-flat-typescript-configs]: [eslint-plugin-jsdoc: Configuration > Granular Flat Configs](https://github.com/gajus/eslint-plugin-jsdoc?tab=readme-ov-file#granular-flat-configs)

[^post-stop-using-eslint-for-formatting]: [Configuring ESLint, Prettier, and TypeScript Together > STOP USING ESLINT FOR FORMATTING](/blog/configuring-eslint-prettier-and-typescript-together/#stop-using-eslint-for-formatting)

[^post-the-blurry-line-between-formatting-and-style]: [The Blurry Line Between Formatting and Style](/blog/the-blurry-line-between-formatting-and-style)

[^rethinking-typescript-support-in-eslint]: [eslint/eslint#18830 Rethinking TypeScript support in ESLint](https://github.com/eslint/eslint/discussions/18830)

[^rfc-feat-parsing-session-objects]: [eslint/rfcs#102 feat: parsing session objects](https://github.com/eslint/rfcs/pull/102)

[^stackoverflow-parsing-error-was-not-found-by-the-project-service-but-ive-ignored-these-file]: [StackOverflow: Parsing error: was not found by the project service, but I've ignored these files](https://stackoverflow.com/a/78873727/1830407)

[^stc-abandoned]: [dudykr/stc#1101 Project is officially abandoned](https://github.com/dudykr/stc/issues/1101)

[^tseslint-discord-help-eslint-not-ignoring-js-files]: [Discord help thread: Eslint not ignoring .js files and throwing Definition for rule ... not found error](https://discord.com/channels/1026804805894672454/1283776448188121158)

[^tseslint-discussion-intent-to-use-checker-is-type-assignable-to]: [typescript-eslint/typescript-eslint#7936 ðŸ”“ Intent to use: checker.isTypeAssignableTo](https://github.com/typescript-eslint/typescript-eslint/discussions/7936)

[^tseslint-explore-ts-vfs]: [typescript-eslint/typescript-eslint#1891 Explore switching tests to @typescript/vfs](https://github.com/typescript-eslint/typescript-eslint/issues/1891)

[^tseslint-pr-new-eslint-parser-on-swc]: [typescript-eslint/typescript-eslint#7680 feat: add a new ESLint parser built on top of SWC](https://github.com/typescript-eslint/typescript-eslint/pull/7680)

[^tseslint-pr-type-checker-wrapper-apis]: [typescript-eslint/typescript-eslint#6404 feat(typescript-estree): add type checker wrapper APIs to ParserServicesWithTypeInformation](https://github.com/typescript-eslint/typescript-eslint/pull/6404)

[^tseslint-troubleshooting-performance-import]: [typescript-eslint Troubleshooting & FAQs > Typed Linting > Performance > `eslint-plugin-import`](https://typescript-eslint.io/troubleshooting/typed-linting/performance#eslint-plugin-import)

[^tseslint-troubleshooting-performance-prettier]: [typescript-eslint Troubleshooting & FAQs > Typed Linting > Performance > `eslint-plugin-prettier`](https://typescript-eslint.io/troubleshooting/typed-linting/performance#eslint-plugin-prettier)

[^tseslint-troubleshooting-performance-stylistic]: [typescript-eslint Troubleshooting & FAQs > Typed Linting > Performance > `@stylistic/ts/indent` and other stylistic rules rules](https://typescript-eslint.io/troubleshooting/typed-linting/performance#stylistictsindent-and-other-stylistic-rules-rules)

[^tseslint-troubleshooting-typed-linting]: [typescript-eslint > Troubleshooting & FAQs > Typed Linting](https://typescript-eslint.io/troubleshooting/typed-linting)

[^typerunner-stalled]: [marcj/TypeRunner Is there still a chance of kickstarting the project?](https://github.com/marcj/TypeRunner/issues/14)

[^typescript-eslint-configs]: [typescript-eslint: Shared Configs > Recommended Configurations](https://typescript-eslint.io/users/configs#recommended-configurations)

[^vscode-eslint-cross-file-information]: [microsoft/vscode-eslint#1774 ESLint does not re-compute cross-file information on file changes](https://github.com/microsoft/vscode-eslint/issues/1774)
