---
pubDate: 2025-05-08
description: "This is how I would tailor the developer experience for a modern linter from scratch: focusing on end-to-end type safety, self-apparent configs, and native workspaces."
image:
  alt: "Tevye from Fiddler on the Roof TODO_ACTIVITY"
  src: "~/assets/blog/sisyphus.jpg"
title: "If I Wrote a Linter, Part 2: Developer Experience"
---

import {
	Tabs,
	TabsList,
	TabsTab,
	TabsPanel,
} from "accessible-astro-components";

import vscodeESLintScreenshot from "~/assets/blog/vscode-eslint-screenshot.png";
import vscodeTerminalESLintMockup from "~/assets/blog/vscode-terminal-eslint-mockup.png";
import vscodeTerminalESLintScreenshot from "~/assets/blog/vscode-terminal-eslint-screenshot.png";
import LabeledImage from "~/components/blog/mdx/LabeledImage.astro";
import LabeledVideo from "~/components/blog/mdx/LabeledVideo.astro";

Today's web linters are great.
[ESLint](https://eslint.org) is robust and has a huge ecosystem of plugins and configs.
Newer native speed linters such as [Biome](https://biomejs.dev), [`deno lint`](https://lint.deno.land), and [Oxlint](https://github.com/oxc-project/oxc) are fast and easy to set up with their own burgeoning ecosystems.

I've been working on TypeScript linting for almost a decade.
I started contributing to [TSLint](https://palantir.github.io/tslint) community projects in 2016 and am now a number of the [typescript-eslint](https://github.com/typescript-eslint/typescript-eslint) and [ESLint](https://github.com/eslint/eslint) teams.
Based on those years of various linters, I've collected a large set of design ideas that I want to try out.

I see a linter that is **fast by default**, **powerful upon request**, and **straightforward to configure**.
This post is how I would craft how developers use it.

> ðŸ’¡ This post is the second in a series:
>
> <br />
>
> - [Part 1: Architecture](/blog/if-i-wrote-a-linter-part-1-architecture)
> - ðŸ‘‰ [Part 2: Developer Experience](/blog/if-i-wrote-a-linter-part-2-developer-experience)
> - Part 3: Ecosystem _([coming soon](https://github.com/JoshuaKGoldberg/dot-com/pull/420 "dot-com pull request 420 Part 3: Ecosystem"))_
> - Part 4: Summary _([coming soon](https://github.com/JoshuaKGoldberg/dot-com/pull/421 "dot-com pull request 421 Part 4: Summary"))_

## Developer Experience is Important

The "developer experience" of a linter an incredibly important part of its usability.
Especially when your tool is made to tell developers when they're "wrong" (which is how many developers interpret linters, sadly).
Linters get an unusually bad rap because they often require extra per-project configuration, and any overly aggressive lint rule makes the act of linting seem unnecessarily painful.

My goals with rethinking a linter's developer experience are:

- Approachability: making sure the common user flows are as documented, straightforward, and difficult-to-mess-up as possible
- Clarity: everything should be as easy as possible to understand, even if you're not an expert
- Minimalism: removing extraneous features and deduplicating tooling configuration
- Type safety: making as much as possible well-typed, both for plugin authors and end-users

## Comprehensive Rule Reports

Rule reports are the entry point for most developers who experience a linter.
The little red or yellow squiggly in an editor that shows rule text on hover is how developers learn about the report.

Linters today generally populate hover text with:

- ID/name, linked to the rule's online documentation
- Text description of the rule report

<LabeledImage
	alt="Screenshot of a VS Code lint hover message: Unexpected `await` of a non-Promise (non-'Thenable') value. eslint(@typescript-eslint/await-thenable)"
	note="Common VS Code hover display of an ESLint report diagnostic"
	src={vscodeESLintScreenshot}
	wide
/>

<LabeledImage
	alt="Screenshot of a terminal report from npx eslint .: 50:1 Unexpected `await` of a non-Promise (non-'Thenable') value (@typescript-eslint/await-thenable)."
	note="Common terminal output from ESLint of a lint report"
	src={vscodeTerminalESLintScreenshot}
	wide
/>

If that message includes too little text, people won't understand the report; too much text, and they won't read any of it.
But many rules' reports have too much conceptual complexity or too many important nuances to fit in a hover message.

If I wrote a linter, rule report bodies would include something like:

- Primary: a single sentence explaining what's wrong
- Secondary: additional sentences explaining the problem in more detail
- Suggestions: recommendations for how to fix the problem
- Shortcut URL to the rule's documentation page

In theory, editor extensions could then visualize these nicely [^vscode-rich-editor-support].
VS Code is unfortunately still waiting on formatted diagnostic text support [^vscode-eslint-issue-markdown-report] [^pretty-ts-errors-docs-hide-original-errors], but I've seen proof-of-concepts in extensions such as [pretty-ts-errors](https://github.com/yoavbls/pretty-ts-errors).

I'd also want to nicely format these in CLI reports.
The Biome [^biome-cli-reference] and TSSLint [^tsslint-cli-reference] CLIs are do a great job of making linter reports approachable and clear.
Bonus shoutouts to Orta's `tsc` explorations [^typescript-pull-orta-cli-reference] and the Rust CLI.
I particularly like how some linters will display on the first report per file and/or per rule, with an opt-in option to show all.

TODO: reference other mockups

If I wrote a linter, it would that kind of rich reporter display by default.
It would at least:

- Default to a "focused" view that only shows a few reports at a time, leaving more space for...
- Friendly primary + secondary + suggestions text for each spotlighted report, using ...
- Rich colors to emphasize which parts of reports are most important
- Trim out unnecessary details, such as parts of file paths above the project root

Here's a very rough starting mockup:

TODO: add...

- top-right?: `[S]` suggestions toggle
- bottom-right?: `<` `>` report navigation; `tab` / `shift-tab` file navigation (?)

<LabeledImage
	alt="Screenshot of a terminal report from npx eslint .: 50:1 Unexpected `await` of a non-Promise (non-'Thenable') value (@typescript-eslint/await-thenable)."
	note={`This is a very rough mockup of the "focused" view; please don't read too much into it.`}
	src={vscodeTerminalESLintMockup}
	wide
/>

The linter's reporting would have to fall back to more primitive colors, or no colors at all, depending on what the running terminal supports.
I also imagine there could be interactive controls to let the user collapse/expand the report and navigate between files or reports within a file.

## Comprehensive Rule Documentation

The next step for many developers who receive a lint report is the rule's documentation page.
The typescript-eslint site includes a pretty rich display for rules, similar to many other lint sites:

- High-level ID/name and description
- High-level metadata, such as which config(s) include the rule and whether it requires type information
- Longer description of the rule
- Examples of configuring the rule, as well as its options if they exist
- When _not_ to use the rule
- Links to the rule's source code, test code, and any related other documentation

Each of those sections are must-haves for any lint rule -- especially one in an open source linter or popular plugin.

If I wrote a linter, I would require all those sections be filled out in every core rule's documentation.
I would additionally attempt to make sure any popular plugin website templates include the sections and fill them out too.

## Standardized Rule Metadata

Users like naming and stylistic standardization.
Without consistent patterns, it becomes much more difficult to remember how things work consistently.
Rule names, option names, option value defaults, and other strings users need to think of when using a linter are easier to remember when they're consistent.

Unfortunately, no mainstream linter today is consistent with its choices -- even internally.
Community plugins often make very different and inconsistent choices as well.
This lack of standardization is painful for users.

If I wrote a linter, it would standardize how rules are named and structured.
The next few sections will explain those the relevant questions I would standardize answers to.

### Standardized Rule Messages

The text of rule messages is pretty inconsistent across rules, even within the same linter or plugin.
Older rules tend to have assertive and curt messages, such as:

- [`no-console`](https://eslint.org/docs/latest/rules/no-console): `Unexpected console statement.`
- [`no-empty`](https://eslint.org/docs/latest/rules/no-empty): `Empty block statement.`

I've found that users don't generally react well to curt messages.
They can feel like the linter saying something is _absolutely wrong_, even though most lint rules are sometimes wrong.
There's a reason why many linters put _"When Not To Use"_ sections in their rule documentation pages.

Newer or more recently updated rule messages tend to be more descriptive and speak to the actual problems the rules detect, such as:

- [`no-loss-of-precision`](https://eslint.org/docs/latest/rules/no-useless-assignment): `This number literal will lose precision at runtime.`
- [`no-useless-assignment`](https://eslint.org/docs/latest/rules/no-useless-assignment): `This assigned value is not used in subsequent statements.`

If I wrote a linter, all core rule messages would have consistent phrasing.
They would never be dogmatic or overly prescriptive about what the user "should" do.
They'd instead just speak to the detected potential problem in code.

### Standardized Rule Names

Rule names have to make several choices:

- Abbreviation:
  - Abbreviated: [`no-cond-assign`](https://eslint.org/docs/latest/rules/no-cond-assign), [`no-const-assign`](https://eslint.org/docs/latest/rules/no-const-assign) / [noConstAssign](https://biomejs.dev/linter/rules/no-const-assign)
  - Unabbreviated: [`no-constant-binary-expression`](https://eslint.org/docs/latest/rules/no-constant-binary-expression) / [noConstantBinaryExpression](https://next.biomejs.dev/linter/rules/no-constant-binary-expression)
- Prefixes:
  - Definitive: `@typescript-eslint/ban-ts-comment`, `no-await-in-loop`
  - Loose: `@typescript-eslint/restrict-plus-operands`, `prefer-const`
  - No prefix: `array-callback-return`, `constructor-super`
- Singularity:
  - Singular: `for-direction`, `default-case-last`
  - Plural: `no-magic-numbers`, `require-atomic-updates`

Inconsistent answers to each of those choices lead to user confusion:

- Abbreviation:
  - Memorize many abbreviations is an annoyance at best and confusing at worst
  - Some words abbreviate to different meanings, such as "constant" and "const"
- Prefixes:
  - Alphabetical sorting of rules places them similarly prefixed rules together, weirdly
  - Many rules have dropped their prefix after adding an option to invert behavior [^tseslint-discussion-no-prefixing-rule-names]
- Singularity: the least troublesome, but I still find the inconsistency painful

If I wrote a linter, core rule names would make one choice for each of those naming options:

- Abbreviation: no abbreviation, so users won't have to memorize dozens of abbreviations
- Singularity: always plural, as that's how one would describe what rules target
- Prefixes: no prefixes; the rules would be named for the behavior or syntax they target

For example, I would rework the following rule names roughly like:

| Current Rule Name                                                                                   | Reworked Rule Name            |
| --------------------------------------------------------------------------------------------------- | ----------------------------- |
| [array-callback-return](https://eslint.org/docs/latest/rules/array-callback-return)                 | `arrayCallbackReturns`        |
| [ban-ts-comment](https://typescript-eslint.io/rules/ban-ts-comment)                                 | `typescriptCommentDirectives` |
| [constructor-super](https://eslint.org/docs/latest/rules/constructor-super)                         | `constructorSuper`            |
| [default-case-last](https://eslint.org/docs/latest/rules/default-case-last)                         | `defaultCaseLast`             |
| [for-direction](https://eslint.org/docs/latest/rules/for-direction)                                 | `forLoopDirections`           |
| [no-await-in-loop](https://eslint.org/docs/latest/rules/no-await-in-loop)                           | `loopAwaits`                  |
| [no-cond-assign](https://eslint.org/docs/latest/rules/no-cond-assign)                               | `conditionalAssignments`      |
| [no-const-assign](https://eslint.org/docs/latest/rules/no-const-assign)                             | `constAssignments`            |
| [no-constant-binary-expression](https://eslint.org/docs/latest/rules/no-constant-binary-expression) | `constantBinaryExpressions`   |
| [no-floating-promises](https://typescript-eslint.io/rules/no-floating-promises)                     | `floatingPromises`            |
| [no-magic-numbers](https://eslint.org/docs/latest/rules/no-magic-numbers)                           | `magicNumbers`                |
| [prefer-const](https://eslint.org/docs/latest/rules/prefer-const)                                   | `constVariables`              |
| [require-atomic-updates](https://typescript-eslint.io/rules/require-atomic-updates)                 | `atomicUpdates`               |
| [restrict-plus-operands](https://typescript-eslint.io/rules/restrict-plus-operands)                 | `plusOperands`                |

### Standardized Rule Options

Rule options have to make an even broader, deeper set of choices:

- Format:
  - Array: [`array-type`](https://typescript-eslint.io/rules/array-type), [`no-restricted-component-names`](https://eslint.vuejs.org/rules/no-restricted-component-names)
  - Object with keys for option names: ...almost all other rules
- Message: how detailed is the first line? How much should it suggest next steps?
- Name:
  - Plurality:
    - Singular: [`no-implicit-coercion` > `boolean`](https://eslint.org/docs/latest/rules/no-implicit-coercion#options)
    - Plural: [`no-floating-promises` > `checkThenables`](https://typescript-eslint.io/rules/no-floating-promises#checkthenables)
  - Prefix:
    - Turning off checks:
      - `allow*`: [`getter-return` > `allowImplicit`](https://eslint.org/docs/latest/rules/getter-return#options)
      - `ignore*`: [`no-trailing-spaces` > `ignoreComments`](https://eslint.style/rules/js/no-trailing-spaces#ignorecomments)
      - `skip*`: [`no-trailing-spaces` > `skipBlankLines`](https://eslint.style/rules/js/no-trailing-spaces#skipblanklines)
    - Turning on checks:
      - `check*`: [`prevent-abbreviations` > `checkProperties`](https://github.com/sindresorhus/eslint-plugin-unicorn/blob/main/docs/rules/prevent-abbreviations.md#checkproperties)
      - `enforce*`: [`accessor-pairs` > `enforceForClassMembers`](https://eslint.org/docs/latest/rules/accessor-pairs#enforceforclassmembers)
      - `include*`: [`no-duplicate-imports` > `includeExports`](https://eslint.org/docs/latest/rules/no-duplicate-imports#options)
      - `require*`: [`arrow-parens` > `requireForBlockBody`](https://eslint.style/rules/js/arrow-parens#requireforblockbody)
- Value defaults:
  - Boolean values:
    - Off-by-default: [`no-floating-promises` > `ignoreIIFE`](https://typescript-eslint.io/rules/no-floating-promises#ignoreiife)
    - On-by-default: [`no-floating-promises` > `ignoreVoid`](https://typescript-eslint.io/rules/no-floating-promises#ignorevoid)
  - Multi-values:
    - Empty by default: [`no-floating-promises` > `allowForKnownSafeCalls`](https://typescript-eslint.io/rules/no-floating-promises#allowforknownsafecalls)
    - Starting set: [`restrict-template-expressions` > `allow`](https://typescript-eslint.io/rules/restrict-template-expressions#allow)

What a list!

If I wrote a linter, core rule options would make the same choice consistently:

- Format: an object with keys for option names
- Messages: see [Comprehensive Rule Reports](#comprehensive-rule-reports)
- Name:
  - Plurality: always plural, as that's how one would describe what rule options target
  - Prefix:
    - `allow*` for options that add in an array of values
    - `check*` for options that turn on a check
    - `ignore*` for options that turn off a check
- Value defaults:
  - Boolean values: off-by-default, for simpler truthiness concepts
  - Multi-values: empty by default, so specifying values doesn't remove defaults

Looking at the options for across several rules, I would rework them roughly like:

| Current Option Name                                                                                                                      | Reworked Option Name | Current Option Default | Reworked Option Default |
| ---------------------------------------------------------------------------------------------------------------------------------------- | -------------------- | ---------------------- | ----------------------- |
| [`allow`](https://typescript-eslint.io/rules/restrict-template-expressions#allow)                                                        | _(same)_             | `[{ ... }]`            | `[]`                    |
| [`allowForKnownSafeCalls`](https://typescript-eslint.io/rules/no-floating-promises#allowforknownsafecalls)                               | _(same)_             | `[]`                   | _(same)_                |
| [`allowImplicit`](https://eslint.org/docs/latest/rules/getter-return#options)                                                            | `ignoreImplicit`     | `false`                | _(same)_                |
| [`array-type`](https://typescript-eslint.io/rules/array-type)'s anonymous element                                                        | `style`              | `'array'`              | _(same)_                |
| [`boolean`](https://eslint.org/docs/latest/rules/no-implicit-coercion#options)                                                           | `booleans`           | `true`                 | `false`                 |
| [`checkProperties`](https://github.com/sindresorhus/eslint-plugin-unicorn/blob/main/docs/rules/prevent-abbreviations.md#checkproperties) | _(same)_             | `false`                | _(same)_                |
| [`checkThenables`](https://typescript-eslint.io/rules/no-floating-promises#checkthenables)                                               | _(same)_             | `false`                | _(same)_                |
| [`enforceForClassMembers`](https://eslint.org/docs/latest/rules/accessor-pairs#enforceforclassmembers)                                   | `ignoreClassMembers` | `true`                 | `false`                 |
| [`ignoreComments`](https://eslint.style/rules/js/no-trailing-spaces#ignorecomments)                                                      | _(same)_             | `false`                | _(same)_                |
| [`ignoreIIFE`](https://typescript-eslint.io/rules/no-floating-promises#ignoreiife)                                                       | _(same)_             | `false`                | _(same)_                |
| [`ignoreVoid`](https://typescript-eslint.io/rules/no-floating-promises#ignorevoid)                                                       | _(same)_             | `true`                 | `false`                 |
| [`includeExports`](https://eslint.org/docs/latest/rules/no-duplicate-imports#options)                                                    | `checkExports`       | `false`                | _(same)_                |
| [`no-restricted-component-names`](https://eslint.vuejs.org/rules/no-restricted-component-names#options)'s anonymous element              | `names`              | `[]`                   | _(same)_                |
| [`requireForBlockBody`](https://eslint.style/rules/js/arrow-parens#requireforblockbody)                                                  | `checkBlockBodies`   | `false`                | _(same)_                |
| [`skipBlankLines`](https://eslint.style/rules/js/no-trailing-spaces#skipblanklines)                                                      | `ignoreBlankLines`   | `false`                | _(same)_                |

Oh, and rule options would be sorted alphabetically in their docs pages.
I want to be able to O(log(N)) scan a docs page for a rule option.
Not O(1) search through some arbitrary order.

### Standardized Specifiers

Some rules allow specifying types or values in their options.
For example, [`@typescript-eslint/no-restricted-types`](https://typescript-eslint.io/rules/no-restricted-types) allows specifying types in its `types` option:

```js
"@typescript-eslint/no-restricted-types": [
	"error",
	{
		"types": {
			"SomeType": "Don't use SomeType because it is unsafe",
		},
	},
]
```

The problem with using plain strings to target names is that they are ambiguous.
In the example, _any_ type named `SomeType` would be restricted, even if it is a different type than the one the user intended.

Over in typescript-eslint, we developed a [TypeOrValueSpecifier](https://typescript-eslint.io/linting/type-or-value-specifier) format for specifying types or values in options.
It allows users to specify not just the name but also the source -global, package, etc.- of a type or value.
Here's how that would look for specifying `SomeType` from a specific file:

```js
"@typescript-eslint/no-restricted-types": [
	"error",
	{
		"types": [{
			"message": "Don't use SomeType because it is unsafe",
			"type": "SomeType",
		}],
	},
]
```

If I wrote a linter, core rules would only ever use the TypeOrValueSpecifier format to specify types or values.
Userland plugins would be strongly encouraged to use the format instead of ambiguous strings.

## Only Errors

All mainstream web linters today allow configuring rules as _errors_ or _warnings_.
Errors are generally visualized with red squigglies and fail builds; warnings are visualized with yellow squigglies and don't fail builds.

Warnings are intended to be transient indicators during migrations or when rules aren't certain about issues [^eslint-pr-docs-warn-severity].
In practice, I think the delineation is not worthwhile:

- Using the same red color and terminology for _lint_ errors and _type-checking_ errors is confusing both ideologically and practically.
  I personally use [VS Code's `eslint.rules.customizations`](https://github.com/microsoft/vscode-eslint/pull/1164) to visualize lint errors with yellow squigglies, to not conflict with red TypeScript squigglies.
- Warnings tend to live forever in codebases, which trains developers to ignore lint reports.
- If a problem can't be determined with certainty, it either should be suppressed using an inline config comment with an explanation, or not turned into a lint rule at all!

I think warnings are a bad fit for the migration use case.
Tools like [eslint-nibble](https://github.com/IanVS/eslint-nibble) and ESLint's new [Bulk Suppressions](https://eslint.org/docs/latest/use/suppressions) can provide a more comprehensive experience.

If I were to write a linter, I would have it so rules can only be turned off or on.
All lint rule reports would be errors and visualized with yellow squigglies in errors.
Gradual onboardings of new rules or rule options would be a separately managed feature.

## Typed Rules

One of my biggest gripes with all existing linter configuration systems today is that _rule options are not type-safe_.
All mainstream linters today have you specify rules as properties an object, where their string key is their plugin name and rule name, and their value is their severity and any options:

```js
{
	"my-plugin/some-rule": ["error", {
		setting: "...",
	}],
}
```

Those string keys have no associated types in config files.
Linters themselves can validate rule options, such as [ESLint's options schemas](https://eslint.org/docs/latest/extend/custom-rules#options-schemas), but those don't translate to TypeScript types.
You don't get editor intellisense while authoring; instead, you have to use [`@eslint/config-inspector`](https://www.npmjs.com/package/@eslint/config-inspector) or run your config to know whether you've mistyped the name of a rule or an option.

I'd love to make a standard plugin creator function that plugin authors are encouraged -even required- to use.
It could take in a set of rules and return some kind of well-typed function.

Vaguely, maybe it'd use a TypeScript-friendly schema validation library such as [Zod](https://zod.dev) and look something like:

```ts
import { createRule, createPlugin } from "@joshuakgoldberg/linter";
import { z } from "zod";

const someRule = createRule({
	options: {
		option: z.string(),
	},
});

export const myPlugin = createPlugin({
	name: "My Plugin",
	rules: [someRule],
});
```

...and in usage could look something like:

```ts
// if-i-wrote-a-linter.config.ts (partial)
({
	rules: [
		myPlugin.rules({
			"some-rule": {
				option: "...",
			},
		}),
	],
});
```

Under that kind of system, users would receive intellisense as they type plugin rules, and all those settings could be type checked.
Doing so would even coincidentally solve the issue of [plugin namespacing and rule config duplication](https://github.com/eslint/eslint/discussions/17766).
Config values would be verified at runtime by the schema validation library.

## Typed Plugin Settings

An even less type-safe part of other current linters' config systems is the [shared `settings` object](https://eslint.org/docs/latest/use/configure/configuration-files#configuring-shared-settings).
You can put whatever you want in there, and any plugin may read from it.

In theory, cross-plugin shared settings can be used for related plugins, while plugin-specific settings are by convention namespaced under their name.
In practice, I don't think I've ever used a shared setting across plugins.

If I wrote a linter, I would have plugins define their own settings and settings types.
They would need to use a TypeScript-friendly schema validation library such as [Zod](https://zod.dev).
It could look something like:

```ts
import { createPlugin } from "@joshuakgoldberg/linter";
import { z } from "zod";

export const myPlugin = createPlugin({
	name: "My Plugin",
	rules: [
		// ...
	],
	settings: {
		mySetting: z.string(),
	},
});
```

...and in usage could look something like:

```ts
// if-i-wrote-a-linter.config.ts (partial)
import { myPlugin } from "@joshuakgoldberg/my-plugin";

myPlugin.settings({
	mySetting: "...",
});
```

As with rules, allowing plugins to define their own settings types would help with the config authoring experience.
It would also newly allow shared settings to be validated by both type-checking and the core linter.
Doing so means plugins can be more confident in defining settings and changing them over time as needed.

## Typed Configuration Files

Linters today fall into two classifications of linter configs:

- Direct JSON ([`biome.json`](https://biomejs.dev/linter/#configuration), [Deno](https://docs.deno.com/runtime/fundamentals/configuration/#linting), [Oxlint](https://oxc.rs/docs/guide/usage/linter#configuration-file))
- Nuanced JS (ESLint: [`.eslintrc.js` (deprecated)](https://eslint.org/docs/latest/use/configure/configuration-files-deprecated), [`eslint.config.js`](https://eslint.org/docs/latest/use/configure/configuration-files))

Direct JSON is a nice and straightforward "walled garden" that shines in small projects.
But I don't think it scales well.
The user experience of typing JSON files isn't great if you're not using a custom editor extension to get JSON intellisense.
Plus, because they can't use native ESM imports, the linters have to implement their own ad hoc module system.

Nuanced JS configurations from ESLint, on the other hand, are "just JavaScript" and so utilize native module importing for plugins, global variables, and shared configurations.
That's great for understandability and simplifying the plugin loading model.
ESLint's flat config is a huge step forward from the confusing `overrides` model of ESLint's legacy configs.

I think ESLint's flat config has learned the hard way:

- With "just" JavaScript objects, there's no way to lint only the user's own config entries [^eslint-issue-change-request-report-unnecessary-config-overrides]
- Directory relativity is confusing when nested configs `import` from a higher-up config [^eslint-issue-change-request-inherit-flat-configs-from-root]
- Global `ignores` needs a separate function or key from local `ignores` [^stackoverflow-parsing-error-was-not-found-by-the-project-service-but-ive-ignored-these-file] [^tseslint-discord-help-eslint-not-ignoring-js-files]
- When plugin configs set file globs and other settings, it's unclear where settings come from

I want a "just JavaScript" config system, but I want it to wholly lean into well-typed functions and objects.
Each line of the config _file_ should make it clear what is being set -- even if you don't understand the nuances of the config _system_.

Here's a rough sketch of what my linter's config could like for a starter TypeScript setup, compared to the closest ESLint equivalent:

<Tabs>
	<TabsList>
		<TabsTab id="tab1" controls="panel1" selected>If I Wrote a Linter</TabsTab>
		<TabsTab id="tab2" controls="panel2">ESLint Equivalent</TabsTab>
	</TabsList>
	<TabsPanel id="panel1" labelledby="tab1" selected>

```ts
// if-i-wrote-a-linter.config.ts
import { defineConfig, ts } from "@joshuakgoldberg/linter";

export default defineConfig({
	use: [
		{
			glob: "**/*.ts",
			rules: [ts.configs.logical, ts.configs.stylistic],
		},
	],
});
```

    </TabsPanel>
    <TabsPanel id="panel2" labelledby="tab2">

```ts
// eslint.config.ts
import eslint from "@eslint/js";
import { defineConfig } from "eslint/config";
import tseslint from "typescript-eslint";

export default defineConfig(
	eslint.configs.recommended,
	tseslint.configs.recommended,
	tseslint.configs.stylistic,
);
```

    </TabsPanel>

</Tabs>

That sketch is different from the current ESLint flat config in a few ways:

- Most settings are moved into an explicit `use` array, each with `glob` and `rules`
- The traditional `extends` is merged into `rules` with plugins registering themselves automatically, rather than a separate `plugins` object
- `rules` is an array of type-safe function calls, rather than a non-type-safe key-value object

Here's how it would look for a repository that configures rules, ignores some files, and adds a plugin with settings:

<Tabs>
	<TabsList>
		<TabsTab id="tab1" controls="panel1" selected>If I Wrote a Linter</TabsTab>
		<TabsTab id="tab2" controls="panel2">ESLint Equivalent</TabsTab>
	</TabsList>
	<TabsPanel id="panel1" labelledby="tab1" selected>

```ts
// if-i-wrote-a-linter.config.ts
import { defineConfig, ts } from "@joshuakgoldberg/linter";
import { example } from "@joshuakgoldberg/plugin-example";

export default defineConfig({
	ignore: ["lib/"],
	use: [
		{
			exclude: ["**/*.generated.ts"],
			glob: "**/*.ts",
			rules: [
				ts.configs.logical,
				ts.configs.stylistic,
				ts.rules({
					ruleA: false,
					ruleB: true,
					ruleC: {
						someRuleOption: true,
					},
				}),
				example.configs.recommended,
				example.rules({
					ruleD: true,
				}),
				example.settings({
					mySetting: "...",
				}),
			],
		},
	],
});
```

  	</TabsPanel>
	<TabsPanel id="panel2" labelledby="tab2">

```ts
// eslint.config.ts
import eslint from "@eslint/js";
import { example } from "@joshuakgoldberg/plugin-example";
import { defineConfig, globalIgnores } from "eslint/config";
import tseslint from "typescript-eslint";

export default defineConfig(
	eslint.configs.recommended,
	tseslint.configs.recommended,
	tseslint.configs.stylistic,
	example.configs.recommended,
	{
		ignores: ["**/*.generated.ts"],
		rules: {
			"@typescript-eslint/rule-a": "off",
			"@typescript-eslint/rule-b": "error",
			"@typescript-eslint/rule-c": [
				"error",
				{
					someRuleOption: true,
				},
			],
			"example/rule-d": "error",
		},
		settings: {
			example: {
				mySetting: "...",
			},
		},
	},
);
```

    </TabsPanel>

</Tabs>

That sketch shows a few more differences from the current ESLint flat config system:

- `defineConfig()` takes in `ignore` as root-level setting, rather than inline with other settings
  - `exclude` inside `use` objects is intentionally a different key from `ignore` for clarity
  - Note: I also want the config system to ignore files listed in your `.gitignore` by default, in addition to ESLint's defaults of `.git/` and `node_modules/`.
- Settings are specified inline in `use` through their plugin, rather than as a separate catch-all `settings` object

I mentioned in part 1 that I would want this linter to support [common languages in core](/blog/if-i-wrote-a-linter-part-1-architecture#common-languages-in-core).
Here's how the config system would look for a repository that enables logical and stylistic rules on all those languages:

<Tabs>
	<TabsList>
		<TabsTab id="tab1" controls="panel1" selected>If I Wrote a Linter</TabsTab>
		<TabsTab id="tab2" controls="panel2">ESLint Equivalent</TabsTab>
	</TabsList>
	<TabsPanel id="panel1" labelledby="tab1" selected>

```ts
// if-i-wrote-a-linter.config.ts
import { defineConfig, md, json, ts, yml } from "@joshuakgoldberg/linter";

export default defineConfig({
	use: [
		{
			glob: "**/*.ts",
			rules: [ts.configs.logical, ts.configs.stylistic],
		},
		{
			glob: "**/*.json",
			rules: [json.configs.recommended],
		},
		{
			glob: "**/*.md",
			rules: [md.configs.recommended],
		},
		{
			glob: "**/*.yml",
			rules: [yml.configs.recommended],
		},
	],
});
```

  	</TabsPanel>
	<TabsPanel id="panel2" labelledby="tab2">

```ts
// eslint.config.ts
import eslint from "@eslint/js";
import jsonc from "eslint-plugin-jsonc";
import markdown from "eslint-plugin-markdown";
import yml from "eslint-plugin-yml";
import { defineConfig } from "eslint/config";
import tseslint from "typescript-eslint";

export default defineConfig(
	eslint.configs.recommended,
	tseslint.configs.recommended,
	tseslint.configs.stylistic,
	markdown.configs.recommended,
	eslintPluginYml.configs["flat/recommended"],
);
```

    </TabsPanel>

</Tabs>

One downside of this proposed approach is that it requires the user to know and manage their file extensions themselves.
Knowing that TypeScript files can also be `*.cts`, `*.mts`, `*.tsx`, etc. is a bit of a pain.
Maybe plugins such as the core linter plugins could provide `globs` constants?

```ts
import { defineConfig, md, json, ts, yml } from "@joshuakgoldberg/linter";

export default defineConfig({
	use: [
		{
			glob: ts.globs.all,
			rules: [ts.configs.logical, ts.configs.stylistic],
		},
	],
});
```

...and what about rules that should be different across different files?
Maybe some TypeScript rules skip or apply different logic to `.d.ts` files [^tseslint-issue-no-var-declarations]?

I suspect having the rules react to the extension of the file being linted would be enough.
A rule can skip linting a file based on its file extension, or really any other information it has on the file.
But we'll see.

### Native Workspace Support

Larger web repositories these days are often structured as "monorepos", often using the "workspace" feature of their package manager and other tools.
Workspaces are particularly useful when different packages in the same repository use very different technology.

If I wrote a linter, I would want native support for workspaces.
I think a root-level lint config file should be able to define common rules and settings for all workspaces.
It should also be able to define where the linter should look for workspace-specific config files.
Then, each workspace could define its own config file that extends the root config and overrides any settings it wants.

Here's a rough sketch of what the root monorepo config could like with a config system inspired by [Vitest workspaces](https://vitest.dev/guide/workspace.html):

```ts
// if-i-wrote-a-linter.config.ts
import { defineConfig, ts } from "@joshuakgoldberg/linter";

export default defineConfig({
	use: [
		{
			glob: "**/*.ts",
			rules: [ts.configs.logical, ts.configs.stylistic],
		},
	],
	workspaces: ["packages/*"],
});
```

Each `packages/*` directory could have its own config that explicitly inherits from the root config:

```ts
// packages/example/if-i-wrote-a-linter.config.ts
import { defineConfig } from "@joshuakgoldberg/linter";
import { example } from "@joshuakgoldberg/plugin-example";

export default defineConfig({
	from: "../..",
	use: [
		{
			exclude: ["**/*.generated.ts"],
			glob: "**/*.ts",
			rules: [
				example.configs.recommended,
				example.rules({
					ruleD: true,
				}),
				example.settings({
					mySetting: "...",
				}),
			],
		},
	],
});
```

## Inline Snapshot Unit Tests

TODO: I want to combine...

- `RuleTester`: the succinctness of inline cases
- TSLint/snapshots: being able to have a quick visual display
- Jest/Vitest-style `-u` snapshots: being able to auto update

TODO: show current state, then...

```ts
ruleTester.run({
	invalid: [
		{
			code: `let value = 123;`,
			output: `const value = 123;`,
			reported: `
				let value = 123;
				    ^^^^^
				    [preferConst] Prefer using 'const' for variables that are never reassigned.
			`,
		},
	],
	valid: [
		`const value = 123;`,
		`
			let value = 123;
			value = 456;
		`,
		`let value;``var value;`,
	],
});
```

Thanks in particular to [Kirk Waiblinger](https://github.com/kirkwaiblinger), fellow typescript-eslint team member, for very helpful advice on the config file format.
Kirk ideated preset `glob` values and helped with balancing clarity of language configurations with its verbosity.

Additional thanks to [Dimitri Mitropoulos (Michigan TypeScript)](https://michigantypescript.com) and (TODO grab from social media) for suggesting references of CLI prior art.

## References

[^biome-cli-reference]: [Biome `no-aria-unsupported-elements` Examples > Invalid](https://biomejs.dev/linter/rules/no-aria-unsupported-elements/#invalid)

[^eslint-issue-change-request-inherit-flat-configs-from-root]: [eslint/eslint#18385 Change Request: Make it easier to inherit flat configs from the repo root #18385](https://github.com/eslint/eslint/issues/18385)

[^eslint-issue-change-request-report-unnecessary-config-overrides]: [eslint/eslint#15476 Change Request: report unnecessary config overrides](https://github.com/eslint/eslint/issues/15476)

[^eslint-pr-docs-warn-severity]: [eslint/eslint#16696 docs: Add explanation of when to use 'warn' severity](https://github.com/eslint/eslint/issues/16696)

[^jsdoc-granular-flat-typescript-configs]: [eslint-plugin-jsdoc: Configuration > Granular Flat Configs](https://github.com/gajus/eslint-plugin-jsdoc?tab=readme-ov-file#granular-flat-configs)

[^pretty-ts-errors-docs-hide-original-errors]: [yoavbls/pretty-ts-errors > docs/hide-original-errors.md](https://github.com/yoavbls/pretty-ts-errors/blob/main/docs/hide-original-errors.md)

[^stackoverflow-parsing-error-was-not-found-by-the-project-service-but-ive-ignored-these-file]: [StackOverflow: Parsing error: was not found by the project service, but I've ignored these files](https://stackoverflow.com/a/78873727/1830407)

[^tseslint-discord-help-eslint-not-ignoring-js-files]: [Discord help thread: Eslint not ignoring .js files and throwing Definition for rule ... not found error](https://discord.com/channels/1026804805894672454/1283776448188121158)

[^tseslint-discussion-no-prefixing-rule-names]: [Suggestion: standardize against prefixing rule names with "no-"](https://github.com/typescript-eslint/typescript-eslint/discussions/6022)

[^tseslint-issue-no-var-declarations]: [typescript-eslint/typescript-eslint#7941 Base rule extension: no-var configuration for declarations](https://github.com/typescript-eslint/typescript-eslint/issues/7941)

[^tseslint-shared-configs]: [typescript-eslint > Users > Shared Configs](https://typescript-eslint.io/users/configs)

[^tseslint-troubleshooting-performance-import]: [typescript-eslint Troubleshooting & FAQs > Typed Linting > Performance > `eslint-plugin-import`](https://typescript-eslint.io/troubleshooting/typed-linting/performance#eslint-plugin-import)

[^tseslint-troubleshooting-performance-prettier]: [typescript-eslint Troubleshooting & FAQs > Typed Linting > Performance > `eslint-plugin-prettier`](https://typescript-eslint.io/troubleshooting/typed-linting/performance#eslint-plugin-prettier)

[^tseslint-troubleshooting-performance-stylistic]: [typescript-eslint Troubleshooting & FAQs > Typed Linting > Performance > `@stylistic/ts/indent` and other stylistic rules rules](https://typescript-eslint.io/troubleshooting/typed-linting/performance#stylistictsindent-and-other-stylistic-rules-rules)

[^tsslint-cli-reference]: [johnsoncodehk/tsslint#50 Include screenshot/gif of the CLI somewhere in this repo?](https://github.com/johnsoncodehk/tsslint/issues/50)

[^typescript-pull-orta-cli-reference]: [Microsoft/TypeScript#49668 Compiler CLI output format update v2](https://github.com/microsoft/TypeScript/issues/45717)

[^vscode-allow-diagnostics-messages-markdown-content]: [microsoft/vscode#54272](https://github.com/microsoft/vscode/issues/54272)

[^vscode-eslint-issue-markdown-report]: [microsoft/vscode-eslint#1761 Support for markdown in the rule's message report](https://github.com/microsoft/vscode-eslint/issues/1761)

[^vscode-rich-editor-support]: [microsoft/vscode `vscode.d.ts`: `DecorationOptions` > `hoverMessage`](https://github.com/microsoft/vscode/blob/977af64fdff5cd967989749204d1e778dfe86f31/src/vscode-dts/vscode.d.ts#L1216)
