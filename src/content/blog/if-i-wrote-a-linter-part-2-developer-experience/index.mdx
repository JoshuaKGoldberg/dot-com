---
pubDate: 2025-05-05
description: "This is how I would tailor the developer experience for a modern linter from scratch: focusing on end-to-end type safety, self-apparent configs, and native workspaces."
image:
  alt: "Tevye from Fiddler on the Roof TODO_ACTIVITY"
  src: "~/assets/blog/sisyphus.jpg"
title: "If I Wrote a Linter, Part 2: Developer Experience"
---

import {
	Tabs,
	TabsList,
	TabsTab,
	TabsPanel,
} from "accessible-astro-components";

import tevyeDancing from "~/assets/blog/tevye-dancing.webp";
import LabeledImage from "~/components/blog/mdx/LabeledImage.astro";
import LabeledVideo from "~/components/blog/mdx/LabeledVideo.astro";

Today's web linters are great.
[ESLint](https://eslint.org) is robust and has a huge ecosystem of plugins and configs.
Newer native speed linters such as [Biome](https://biomejs.dev), [`deno lint`](https://lint.deno.land), and [Oxlint](https://github.com/oxc-project/oxc) are fast and easy to set up with their own burgeoning ecosystems.

I've been working on TypeScript linting for almost a decade.
I started contributing to [TSLint](https://palantir.github.io/tslint) community projects in 2016 and am now a number of the [typescript-eslint](https://github.com/typescript-eslint/typescript-eslint) and [ESLint](https://github.com/eslint/eslint) teams.
Based on those years of various linters, I've collected a large set of design ideas that I want to try out.

I see a linter that is **fast by default**, **powerful upon request**, and **straightforward to configure**.
This post is how I would craft how developers use it.

> ðŸ’¡ This post is the second in a series:
>
> <br />
>
> - [Part 1: Architecture](/blog/if-i-wrote-a-linter-part-1-architecture)
> - ðŸ‘‰ [Part 2: Developer Experience](/blog/if-i-wrote-a-linter-part-2-developer-experience)
> - Part 3: Ecosystem _([coming soon](https://github.com/JoshuaKGoldberg/dot-com/pull/420 "dot-com pull request 420 Part 3: Ecosystem"))_
> - Part 4: Summary _([coming soon](https://github.com/JoshuaKGoldberg/dot-com/pull/421 "dot-com pull request 421 Part 4: Summary"))_

## Developer Experience is Important

The "developer experience" of a linter an incredibly important part of its usability.
Especially when your tool is made to tell developers when they're "wrong" (or, at least, when developers interpret your tool in that way).
Many developers dislike any tool that tells them they're wrong.
Linters also get an unusually bad rap because they often require extra per-project configuration, and any overly aggressive lint rule makes the act of linting seem unnecessarily painful.

My goals with rethinking a linter's developer experience are:

- Approachability: making sure the common user flows are as documented, straightforward, and difficult-to-mess-up as possible
- Clarity: everything should be as easy as possible to understand, even if you're not an expert
- Minimalism: removing extraneous features and deduplicating tooling configuration
- Type safety: making as much as possible well-typed, both for plugin authors and end-users

## Comprehensive Rule Reports

Rule reports are the entry point for most developers who experience a linter.
The little red or yellow squiggly in an editor that shows rule text on hover is how developers learn about the report.

Linters today generally populate hover text with:

- ID/name, linked to the rule's online documentation
- Text description of the rule report

TODO: example `createWork();` hover

If that message includes too little text, people won't understand the report; too much text, and they won't read any of it.
That sweet spot of text isn't easy to find.
For some nuanced rules, such as [typescript-eslint's `@typescript-eslint/no-floating-promises`](https://typescript-eslint.io/rules/no-floating-promises), report descriptions are generally complex to fit in a hover message.

If I wrote a linter, rule report bodies would include something like:

- Primary: a single sentence explaining what's wrong
- Secondary: additional sentences explaining the problem in more detail
- Suggestions: recommendations for how to fix the problem

Editor extensions could then visualize these nicely, such as with [VS Code's rich hover message support](https://github.com/microsoft/vscode/blob/977af64fdff5cd967989749204d1e778dfe86f31/src/vscode-dts/vscode.d.ts#L1216).

TODO: example editor mockup

I'd also want to nicely format these in CLI reports:

TODO: example CLI mockup

## Comprehensive Rule Documentation

The next step for many developers who receive a lint report is the rule's documentation page.
The typescript-eslint site includes a pretty rich display for rules, similar to many other lint sites:

- High-level ID/name and description
- High-level metadata, such as which config(s) include the rule and whether it requires type information
- Longer description of the rule
- Examples of configuring the rule, as well as its options if they exist
- When _not_ to use the rule
- Links to the rule's source code, test code, and any related other documentation

Each of those sections are must-haves for any lint rule -- especially one in an open source linter or popular plugin.

If I wrote a linter, I would require all those sections be filled out in every core rule's documentation.
I would additionally attempt to make sure any popular plugin website templates include the sections and fill them out too.

## Standardized Rule Metadata

I hate how non-standardized the metadata of lint rules is:

- IDs/names: `no-*`? `prefer-*`? Just the `*` (functionality)?
- Messages: how detailed is the first message? How much should it suggest remediation(s), if at all?
- Options: an array of literals? an object with keys for option names?
  - Option defaults: `allow*`? `check*`? `enforce*`? `require*`? Just the `*` (functionality)?
  - Option defaults: off-by-default? on-by-default?

No linter is consistent with its choices, and community plugins often make very different and inconsistent choices as well.
This lack of standardization is painful for users.
Without consistent patterns, it becomes much more difficult to remember how things work consistently.

If I wrote a linter, I would want to standardize the metadata of all rules.

- IDs/names: just the `*` (functionality)
- Messages: should be resolved by [Comprehensive Rule Reports](#comprehensive-rule-reports)
- Options: always an object with keys for option names
  - Option defaults: the default value should always be empty/falsy, and anything else is confusing
  - Option names: I'm not sure yet of the naming, but _something_ standardized -- maybe...
  - `allow*` for options that allow something
  - `check*` for options that turn on a check
  - `ignore*` for options that turn off a check

### Standardized Rule Names

I would rework the following rule names:

<table>
	<thead>
		<tr>
			<th>Current Rule Name</th>
			<th>Reworked Rule Name</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td>
				<a
					href="https://typescript-eslint.io/rules/no-floating-promises"
					target="_blank"
				>
					<code>no-floating-promises</code>
				</a>
			</td>
			<td rowspan="6">
				<code>floatingPromises</code>
			</td>
		</tr>
	</tbody>
</table>

### Standardized Rule Options

Looking at the options for `no-floating-promises`, I would rework them like:

<table>
	<thead>
		<tr>
			<th>Current Option Name</th>
			<th>Reworked Option Name</th>
			<th>Current Option Default</th>
			<th>Reworked Option Default</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td>
				<code>allowForKnownSafeCalls</code>
			</td>
			<td>
				<em>(same)</em>
			</td>
			<td>
				<code>[]</code>
			</td>
			<td>
				<em>(same)</em>
			</td>
		</tr>
		<tr>
			<td>
				<code>allowForKnownSafePromises</code>
			</td>
			<td>
				<em>(same)</em>
			</td>
			<td>
				<code>[]</code>
			</td>
			<td>
				<em>(same)</em>
			</td>
		</tr>
		<tr>
			<td>
				<code>checkThenables</code>
			</td>
			<td>
				<em>(same)</em>
			</td>
			<td>
				<code></code>
			</td>
			<td>
				<em>(same)</em>
			</td>
		</tr>
		<tr>
			<td>
				<code>ignoreIIFE</code>
			</td>
			<td>
				<em>(same)</em>
			</td>
			<td>
				<code></code>
			</td>
			<td>
				<em>(same)</em>
			</td>
		</tr>
		<tr>
			<td>
				<code>ignoreVoid</code>
			</td>
			<td>
				<em>(same)</em>
			</td>
			<td>
				<code>true</code>
			</td>
			<td>
				<code>false</code>
			</td>
		</tr>
	</tbody>
</table>

## Only Errors

All mainstream web linters today allow configuring rules as _errors_ or _warnings_.
Errors are generally visualized with red squigglies and fail builds; warnings are visualized with yellow squigglies and don't fail builds.

Warnings are intended to be transient indicators during migrations or when rules aren't certain about issues [^eslint-pr-docs-warn-severity].
In practice, I think the delineation is not worthwhile:

- Using the same red color and terminology for _lint_ errors and _type-checking_ errors is confusing both ideologically and practically.
  I personally use [VS Code's `eslint.rules.customizations`](https://github.com/microsoft/vscode-eslint/pull/1164) to visualize lint errors with yellow squigglies, to not conflict with red TypeScript squigglies.
- Warnings tend to live forever in codebases, which trains developers to ignore lint reports.
- If a problem can't be determined with certainty, it either should be suppressed using an inline config comment with an explanation, or not turned into a lint rule at all!

I think warnings are a bad fit for the migration use case.
Tools like [eslint-nibble](https://github.com/IanVS/eslint-nibble) and ESLint's new [Bulk Suppressions](https://eslint.org/docs/latest/use/suppressions) can provide a more comprehensive experience.

If I were to write a linter, I would have it so rules can only be turned off or on.
All lint rule reports would be errors and visualized with yellow squigglies in errors.
Gradual onboardings of new rules or rule options would be a separately managed feature.

## Typed Rules

One of my biggest gripes with all existing linter configuration systems today is that _rule options are not type-safe_.
All mainstream linters today have you specify rules as properties an object, where their string key is their plugin name and rule name, and their value is their severity and any options:

```js
{
	"my-plugin/some-rule": ["error", {
		setting: "...",
	}],
}
```

Those string keys have no associated types in config files.
Linters themselves can validate rule options, such as [ESLint's options schemas](https://eslint.org/docs/latest/extend/custom-rules#options-schemas), but those don't translate to TypeScript types.
You don't get editor intellisense while authoring; instead, you have to use [`@eslint/config-inspector`](https://www.npmjs.com/package/@eslint/config-inspector) or run your config to know whether you've mistyped the name of a rule or an option.

I'd love to make a standard plugin creator function that plugin authors are encouraged -even required- to use.
It could take in a set of rules and return some kind of well-typed function.

Vaguely, maybe it'd use a TypeScript-friendly schema validation library such as [Zod](https://zod.dev) and look something like:

```ts
import { createRule, createPlugin } from "@joshuakgoldberg/linter";
import { z } from "zod";

const someRule = createRule({
	options: {
		option: z.string(),
	},
});

export const myPlugin = createPlugin({
	name: "My Plugin",
	rules: [someRule],
});
```

...and in usage could look something like:

```ts
// if-i-wrote-a-linter.config.ts (partial)
({
	rules: [
		myPlugin.rules({
			"some-rule": {
				option: "...",
			},
		}),
	],
});
```

Under that kind of system, users would receive intellisense as they type plugin rules, and all those settings could be type checked.
Doing so would even coincidentally solve the issue of [plugin namespacing and rule config duplication](https://github.com/eslint/eslint/discussions/17766).
Config values would be verified at runtime by the schema validation library.

## Typed Plugin Settings

An even less type-safe part of other current linters' config systems is the [shared `settings` object](https://eslint.org/docs/latest/use/configure/configuration-files#configuring-shared-settings).
You can put whatever you want in there, and any plugin may read from it.

In theory, cross-plugin shared settings can be used for related plugins, while plugin-specific settings are by convention namespaced under their name.
In practice, I don't think I've ever used a shared setting across plugins.

If I wrote a linter, I would have plugins define their own settings and settings types.
They would need to use a TypeScript-friendly schema validation library such as [Zod](https://zod.dev).
It could look something like:

```ts
import { createPlugin } from "@joshuakgoldberg/linter";
import { z } from "zod";

export const myPlugin = createPlugin({
	name: "My Plugin",
	rules: [
		// ...
	],
	settings: {
		mySetting: z.string(),
	},
});
```

...and in usage could look something like:

```ts
// if-i-wrote-a-linter.config.ts (partial)
import { myPlugin } from "@joshuakgoldberg/my-plugin";

myPlugin.settings({
	mySetting: "...",
});
```

As with rules, allowing plugins to define their own settings types would help with the config authoring experience.
It would also newly allow shared settings to be validated by both type-checking and the core linter.
Doing so means plugins can be more confident in defining settings and changing them over time as needed.

## Typed Configuration Files

Linters today fall into two classifications of linter configs:

- Direct JSON ([`biome.json`](https://biomejs.dev/linter/#configuration), [Deno](https://docs.deno.com/runtime/fundamentals/configuration/#linting), [Oxlint](https://oxc.rs/docs/guide/usage/linter#configuration-file))
- Nuanced JS (ESLint: [`.eslintrc.js` (deprecated)](https://eslint.org/docs/latest/use/configure/configuration-files-deprecated), [`eslint.config.js`](https://eslint.org/docs/latest/use/configure/configuration-files))

Direct JSON is a nice and straightforward "walled garden" that shines in small projects.
But I don't think it scales well.
The user experience of typing JSON files isn't great if you're not using a custom editor extension to get JSON intellisense.
Plus, because they can't use native ESM imports, the linters have to implement their own ad hoc module system.

Nuanced JS configurations from ESLint, on the other hand, are "just JavaScript" and so utilize native module importing for plugins, global variables, and shared configurations.
That's great for understandability and simplifying the plugin loading model.
ESLint's flat config is a huge step forward from the confusing `overrides` model of ESLint's legacy configs.

I think ESLint's flat config has learned the hard way:

- With "just" JavaScript objects, there's no way to lint only the user's own config entries [^eslint-issue-change-request-report-unnecessary-config-overrides]
- Directory relativity is confusing when nested configs `import` from a higher-up config [^eslint-issue-change-request-inherit-flat-configs-from-root]
- Global `ignores` needs a separate function or key from local `ignores` [^stackoverflow-parsing-error-was-not-found-by-the-project-service-but-ive-ignored-these-file] [^tseslint-discord-help-eslint-not-ignoring-js-files]
- When plugin configs set file globs and other settings, it's unclear where settings come from

I want a "just JavaScript" config system, but I want it to wholly lean into well-typed functions and objects.
Each line of the config _file_ should make it clear what is being set -- even if you don't understand the nuances of the config _system_.

Here's a rough sketch of what my linter's config could like for a starter TypeScript setup, compared to the closest ESLint equivalent:

<Tabs>
	<TabsList>
		<TabsTab id="tab1" controls="panel1" selected>If I Wrote a Linter</TabsTab>
		<TabsTab id="tab2" controls="panel2">ESLint Equivalent</TabsTab>
	</TabsList>
	<TabsPanel id="panel1" labelledby="tab1" selected>

```ts
// if-i-wrote-a-linter.config.ts
import { defineConfig, ts } from "@joshuakgoldberg/linter";

export default defineConfig({
	use: [
		{
			glob: "**/*.ts",
			rules: [ts.configs.logical, ts.configs.stylistic],
		},
	],
});
```

    </TabsPanel>
    <TabsPanel id="panel2" labelledby="tab2">

```ts
// eslint.config.ts
import eslint from "@eslint/js";
import { defineConfig } from "eslint/config";
import tseslint from "typescript-eslint";

export default defineConfig(
	eslint.configs.recommended,
	tseslint.configs.recommended,
	tseslint.configs.stylistic,
);
```

    </TabsPanel>

</Tabs>

That sketch is different from the current ESLint flat config in a few ways:

- Most settings are moved into an explicit `use` array, each with `glob` and `rules`
- The traditional `extends` is merged into `rules` with plugins registering themselves automatically, rather than a separate `plugins` object
- `rules` is an array of type-safe function calls, rather than a non-type-safe key-value object

Here's how it would look for a repository that configures rules, ignores some files, and adds a plugin with settings:

<Tabs>
	<TabsList>
		<TabsTab id="tab1" controls="panel1" selected>If I Wrote a Linter</TabsTab>
		<TabsTab id="tab2" controls="panel2">ESLint Equivalent</TabsTab>
	</TabsList>
	<TabsPanel id="panel1" labelledby="tab1" selected>

```ts
// if-i-wrote-a-linter.config.ts
import { defineConfig, ts } from "@joshuakgoldberg/linter";
import { example } from "@joshuakgoldberg/plugin-example";

export default defineConfig({
	ignore: ["lib/"],
	use: [
		{
			exclude: ["**/*.generated.ts"],
			glob: "**/*.ts",
			rules: [
				ts.configs.logical,
				ts.configs.stylistic,
				ts.rules({
					ruleA: false,
					ruleB: true,
					ruleC: {
						someRuleOption: true,
					},
				}),
				example.configs.recommended,
				example.rules({
					ruleD: true,
				}),
				example.settings({
					mySetting: "...",
				}),
			],
		},
	],
});
```

  	</TabsPanel>
	<TabsPanel id="panel2" labelledby="tab2">

```ts
// eslint.config.ts
import eslint from "@eslint/js";
import { example } from "@joshuakgoldberg/plugin-example";
import { defineConfig, globalIgnores } from "eslint/config";
import tseslint from "typescript-eslint";

export default defineConfig(
	eslint.configs.recommended,
	tseslint.configs.recommended,
	tseslint.configs.stylistic,
	example.configs.recommended,
	{
		ignores: ["**/*.generated.ts"],
		rules: {
			"@typescript-eslint/rule-a": "off",
			"@typescript-eslint/rule-b": "error",
			"@typescript-eslint/rule-c": [
				"error",
				{
					someRuleOption: true,
				},
			],
			"example/rule-d": "error",
		},
		settings: {
			example: {
				mySetting: "...",
			},
		},
	},
);
```

    </TabsPanel>

</Tabs>

That sketch shows a few more differences from the current ESLint flat config system:

- `defineConfig()` takes in `ignore` as root-level setting, rather than inline with other settings
  - `exclude` inside `use` objects is intentionally a different key from `ignore` for clarity
  - Note: I also want the config system to ignore files listed in your `.gitignore` by default, in addition to ESLint's defaults of `.git/` and `node_modules/`.
- Settings are specified inline in `use` through their plugin, rather than as a separate catch-all `settings` object

I mentioned in part 1 that I would want this linter to support [common languages in core](/blog/if-i-wrote-a-linter-part-1-architecture#common-languages-in-core).
Here's how the config system would look for a repository that enables logical and stylistic rules on all those languages:

<Tabs>
	<TabsList>
		<TabsTab id="tab1" controls="panel1" selected>If I Wrote a Linter</TabsTab>
		<TabsTab id="tab2" controls="panel2">ESLint Equivalent</TabsTab>
	</TabsList>
	<TabsPanel id="panel1" labelledby="tab1" selected>

```ts
// if-i-wrote-a-linter.config.ts
import { defineConfig, md, json, ts, yml } from "@joshuakgoldberg/linter";

export default defineConfig({
	use: [
		{
			glob: "**/*.ts",
			rules: [ts.configs.logical, ts.configs.stylistic],
		},
		{
			glob: "**/*.json",
			rules: [json.configs.recommended],
		},
		{
			glob: "**/*.md",
			rules: [md.configs.recommended],
		},
		{
			glob: "**/*.yml",
			rules: [yml.configs.recommended],
		},
	],
});
```

  	</TabsPanel>
	<TabsPanel id="panel2" labelledby="tab2">

```ts
// eslint.config.ts
import eslint from "@eslint/js";
import jsonc from "eslint-plugin-jsonc";
import markdown from "eslint-plugin-markdown";
import yml from "eslint-plugin-yml";
import { defineConfig } from "eslint/config";
import tseslint from "typescript-eslint";

export default defineConfig(
	eslint.configs.recommended,
	tseslint.configs.recommended,
	tseslint.configs.stylistic,
	markdown.configs.recommended,
	eslintPluginYml.configs["flat/recommended"],
);
```

    </TabsPanel>

</Tabs>

One downside of this proposed approach is that it requires the user to know and manage their file extensions themselves.
Knowing that TypeScript files can also be `*.cts`, `*.mts`, `*.tsx`, etc. is a bit of a pain.
Maybe plugins such as the core linter plugins could provide `globs` constants?

```ts
import { defineConfig, md, json, ts, yml } from "@joshuakgoldberg/linter";

export default defineConfig({
	use: [
		{
			glob: ts.globs.all,
			rules: [ts.configs.logical, ts.configs.stylistic],
		},
	],
});
```

...and what about rules that should be different across different files?
Maybe some TypeScript rules skip or apply different logic to `.d.ts` files [^tseslint-issue-no-var-declarations]?

I suspect having the rules react to the extension of the file being linted would be enough.
A rule can skip linting a file based on its file extension, or really any other information it has on the file.
But we'll see.

## Native Workspace Support

Larger web repositories these days are often structured as "monorepos", often using the "workspace" feature of their package manager and other tools.
Workspaces are particularly useful when different packages in the same repository use very different technology.

If I wrote a linter, I would want native support for workspaces.
I think a root-level lint config file should be able to define common rules and settings for all workspaces.
It should also be able to define where the linter should look for workspace-specific config files.
Then, each workspace could define its own config file that extends the root config and overrides any settings it wants.

Here's a rough sketch of what the root monorepo config could like with a config system inspired by [Vitest workspaces](https://vitest.dev/guide/workspace.html):

```ts
// if-i-wrote-a-linter.config.ts
import { defineConfig, ts } from "@joshuakgoldberg/linter";

export default defineConfig({
	use: [
		{
			glob: "**/*.ts",
			rules: [ts.configs.logical, ts.configs.stylistic],
		},
	],
	workspaces: ["packages/*"],
});
```

Each `packages/*` directory could have its own config that explicitly inherits from the root config:

```ts
// packages/example/if-i-wrote-a-linter.config.ts
import { defineConfig } from "@joshuakgoldberg/linter";
import { example } from "@joshuakgoldberg/plugin-example";

export default defineConfig({
	from: "../..",
	use: [
		{
			exclude: ["**/*.generated.ts"],
			glob: "**/*.ts",
			rules: [
				example.configs.recommended,
				example.rules({
					ruleD: true,
				}),
				example.settings({
					mySetting: "...",
				}),
			],
		},
	],
});
```

Thanks to [Kirk Waiblinger](https://github.com/kirkwaiblinger), fellow typescript-eslint team member, for very helpful advice on the config file format.
Kirk in particular ideated preset `glob` values and how to balance clarity of language configurations with its verbosity.

## References

[^eslint-issue-change-request-inherit-flat-configs-from-root]: [eslint/eslint#18385 Change Request: Make it easier to inherit flat configs from the repo root #18385](https://github.com/eslint/eslint/issues/18385)

[^eslint-issue-change-request-report-unnecessary-config-overrides]: [eslint/eslint#15476 Change Request: report unnecessary config overrides](https://github.com/eslint/eslint/issues/15476)

[^eslint-pr-docs-warn-severity]: [eslint/eslint#16696 docs: Add explanation of when to use 'warn' severity](https://github.com/eslint/eslint/issues/16696)

[^jsdoc-granular-flat-typescript-configs]: [eslint-plugin-jsdoc: Configuration > Granular Flat Configs](https://github.com/gajus/eslint-plugin-jsdoc?tab=readme-ov-file#granular-flat-configs)

[^stackoverflow-parsing-error-was-not-found-by-the-project-service-but-ive-ignored-these-file]: [StackOverflow: Parsing error: was not found by the project service, but I've ignored these files](https://stackoverflow.com/a/78873727/1830407)

[^tseslint-discord-help-eslint-not-ignoring-js-files]: [Discord help thread: Eslint not ignoring .js files and throwing Definition for rule ... not found error](https://discord.com/channels/1026804805894672454/1283776448188121158)

[^tseslint-issue-no-var-declarations]: [typescript-eslint/typescript-eslint#7941 Base rule extension: no-var configuration for declarations](https://github.com/typescript-eslint/typescript-eslint/issues/7941)

[^tseslint-shared-configs]: [typescript-eslint > Users > Shared Configs](https://typescript-eslint.io/users/configs/)

[^tseslint-troubleshooting-performance-import]: [typescript-eslint Troubleshooting & FAQs > Typed Linting > Performance > `eslint-plugin-import`](https://typescript-eslint.io/troubleshooting/typed-linting/performance#eslint-plugin-import)

[^tseslint-troubleshooting-performance-prettier]: [typescript-eslint Troubleshooting & FAQs > Typed Linting > Performance > `eslint-plugin-prettier`](https://typescript-eslint.io/troubleshooting/typed-linting/performance#eslint-plugin-prettier)

[^tseslint-troubleshooting-performance-stylistic]: [typescript-eslint Troubleshooting & FAQs > Typed Linting > Performance > `@stylistic/ts/indent` and other stylistic rules rules](https://typescript-eslint.io/troubleshooting/typed-linting/performance#stylistictsindent-and-other-stylistic-rules-rules)

[^no-floating-promises-ignore-void]:
    I think allowing `void` by default in no-floating-promises rules is wrong and we should never have kept it.
    It was a bug in my initial implementation of the rule, and has been infuriating me ever since.
