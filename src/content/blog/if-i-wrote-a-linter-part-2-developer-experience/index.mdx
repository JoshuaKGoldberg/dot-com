---
pubDate: 2025-05-09
description: "This is how I would tailor the developer experience for a modern linter from scratch: focusing on end-to-end type safety, self-apparent configs, and native workspaces."
image:
  alt: "Elsa from Frozen walking up a staircase as she's creating it with ice, singing 'Let It Go'"
  src: "~/assets/blog/elsa-let-it-go-stairs-square.png"
thumbnail: "~/assets/blog/elsa-let-it-go-stairs-wide.png"
title: "If I Wrote a Linter, Part 2: Developer Experience"
---

import {
	Tabs,
	TabsList,
	TabsTab,
	TabsPanel,
} from "accessible-astro-components";

import arnoldMagicSchoolBusMrFreeze from "~/assets/blog/arnold-magic-school-bus-mr-freeze.webm";
import doYouWannaBuildALinter from "~/assets/blog/do-you-wanna-build-a-linter.webm";
import elsaLetItGoStairs from "~/assets/blog/elsa-let-it-go-stairs.webm";
import elsaFloorIcePillars from "~/assets/blog/elsa-floor-ice-pillars.webm";
import olafSnowAngelBliss from "~/assets/blog/olaf-snow-angel-bliss.webm";
import vscodeESLintScreenshot from "~/assets/blog/vscode-eslint-screenshot.png";
import vscodeTerminalESLintMockup from "~/assets/blog/vscode-terminal-eslint-mockup.png";
import vscodeTerminalESLintScreenshot from "~/assets/blog/vscode-terminal-eslint-screenshot.png";
import LabeledImage from "~/components/blog/mdx/LabeledImage.astro";
import LabeledVideo from "~/components/blog/mdx/LabeledVideo.astro";

Today's web linters are great.
[ESLint](https://eslint.org) is robust and has a huge ecosystem of plugins and configs.
Newer native speed linters such as [Biome](https://biomejs.dev), [`deno lint`](https://lint.deno.land), and [Oxlint](https://oxc.rs/docs/guide/usage/linter.html) are fast and easy to set up with their own burgeoning ecosystems.

I've been working on TypeScript linting for almost a decade.
I started contributing to [TSLint](https://palantir.github.io/tslint) community projects in 2016 and am now a member of the [typescript-eslint](https://github.com/typescript-eslint/typescript-eslint) and [ESLint](https://github.com/eslint/eslint) teams.
Based on those years of various linters, I've collected a large set of design ideas that I want to try.

I see a linter that is **fast by default**, **powerful upon request**, and **straightforward to configure**.
This post is how I would craft the ways developers would interact with it.

<LabeledVideo
	alt="Elsa from Frozen walking up a staircase as she's creating it with ice, singing 'Let It Go'"
	description="Elsa breaking free from the shackles of linters reporting both errors and warnings."
	original="https://giphy.com/gifs/frozen-movie-disney-Jsdc7bQe7g3WU"
	src={elsaLetItGoStairs}
/>

> ðŸ’¡ This post is the second in a series:
>
> <br />
>
> - [Part 1: Architecture](/blog/if-i-wrote-a-linter-part-1-architecture)
> - ðŸ‘‰ [Part 2: Developer Experience](/blog/if-i-wrote-a-linter-part-2-developer-experience)
> - [Part 3: Ecosystem](/blog/if-i-wrote-a-linter-part-3-ecosystem)
> - [Part 4: Summary](/blog/if-i-wrote-a-linter-part-4-summary)

## Developer Experience is Crucial

The developer experience of a linter an incredibly important part of its usability.
Especially when your tool tells developers they're "wrong" (which is how many interpret linters, sadly).
Linters have have earned that bad reputation for a few reasons:

- Any overly aggressive lint rule makes the act of linting seem unnecessarily painful
- Linters often require extra per-project configuration
- Many older lint rules used to be overly prescriptive
- ...did I mention developers _hate_ being told they're wrong?

My goals with rethinking a linter's developer experience are:

- **Approachability**: features should be as straightforward and difficult-to-mess-up as possible
- **Clarity**: everything should be as easy as possible to understand, even if you're not an expert
- **Minimalism**: removing extraneous features and deduplicating tooling configuration
- **Type safety**: making as much as possible well-typed, both for plugin authors and end-users

The more we make a linter accessible and friendly, the more likely developers are to embrace it.

## Only Errors

All mainstream web linters today allow configuring rules as _errors_ or _warnings_.
Errors are generally visualized with red squigglies and fail builds; warnings are visualized with yellow squigglies and don't fail builds.

Warnings are intended to be transient indicators during migrations or when rules aren't certain about issues [^eslint-pr-docs-warn-severity].
In practice, I think that delineation is not worthwhile:

- Using the same red color and terminology for _lint_ errors and _type-checking_ errors is confusing.
  I personally use [VS Code's `eslint.rules.customizations`](https://github.com/microsoft/vscode-eslint/pull/1164) to visualize lint errors with yellow squigglies, so as to not conflict with TypeScript's red squigglies.
- Warnings tend to live forever in codebases, which trains developers to ignore lint reports.
- If a problem can't be determined with certainty, it either should be suppressed using an inline config comment with an explanation, or not turned into a lint rule at all!

I think warnings are a bad fit for the migration use case.
Tools like [eslint-nibble](https://github.com/IanVS/eslint-nibble) and ESLint's new [Bulk Suppressions](https://eslint.org/docs/latest/use/suppressions) can provide a more comprehensive experience.

If I wrote a linter, I would have it so rules can only be turned off or on.
All lint rule reports would be errors and visualized with yellow squigglies in errors.
Gradual onboardings of new rules or rule options would be a separately managed feature.

<LabeledVideo
	alt="Olaf from Frozen happily making a snow angel in fresh field of snow"
	description="Olaf enjoying the pure, untainted bliss of not having multiple severities for linter rule reports."
	original="https://giphy.com/gifs/disneyanimation-frozen-film-Fjy5XItIvYjEQ"
	src={olafSnowAngelBliss}
/>

## Comprehensive Rule Reports

Rule reports are the entry point for most developers who experience a linter.
The little red or yellow squiggly in an editor that shows rule text on hover is how developers learn about the report.

Linters today generally populate hover text with:

- ID/name, linked to the rule's online documentation
- Text description of the rule report

<LabeledImage
	alt="Screenshot of a VS Code lint hover message: Unexpected `await` of a non-Promise (non-'Thenable') value. eslint(@typescript-eslint/await-thenable)"
	note="Common VS Code hover display of an ESLint report diagnostic"
	src={vscodeESLintScreenshot}
	wide
/>

<LabeledImage
	alt="Screenshot of a terminal report from npx eslint .: 50:1 Unexpected `await` of a non-Promise (non-'Thenable') value (@typescript-eslint/await-thenable)."
	note="Common terminal output from ESLint of a lint report"
	src={vscodeTerminalESLintScreenshot}
	wide
/>

If that message includes too little text, people won't understand the report.
Too much text, and they won't read any of it.
Many rules' reports have too much conceptual complexity or too many important nuances to fit in a brief hover message.

If I wrote a linter, rule report bodies would include something like:

- Primary: a single sentence explaining what's wrong
- Secondary: additional sentences explaining the problem in more detail
- Suggestions: recommendations for how to fix the problem
- Shortcut URL to the rule's documentation page

Rich structured rule reports would enable rich displays in reporters that surface those errors to users.

### Comprehensive Editor Reports (In Theory)

In theory, editor extensions could then visualize these nicely [^vscode-rich-editor-support].
In practice, VS Code is unfortunately still waiting on formatted diagnostic text support [^vscode-eslint-issue-markdown-report] [^pretty-ts-errors-docs-hide-original-errors].

I've seen proof-of-concepts in extensions such as [pretty-ts-errors](https://github.com/yoavbls/pretty-ts-errors) -- but they require unseemly workarounds.

Ugh.

### Comprehensive CLI Reports

Terminals these days can do a lot more more than just print text in preset colors.
They can display hex codes, format links as plain text, and even re-render quickly for interactive displays.

The Biome [^biome-cli-reference], TSSLint [^tsslint-cli-reference], and Vitest [^vitest-cli-reference] CLIs do a great job of making rule reports approachable and clear.
Bonus shoutouts to Orta's `tsc` explorations [^typescript-pull-orta-cli-reference] and userland Rust error reporting crates [^rust-ariadne] [^rust-codespan] [^rust-miette].
I particularly like how some CLIs display only the first report per file and/or per rule, with an opt-in option to show all.

If I wrote a linter, it would include some kind of interactive rich reporter display by default.
It would at least:

- Trim out unnecessary details, such as parts of file paths above the project root
- Default to a "focused" view that only shows a few reports at a time, leaving more space for...
- Friendly primary + secondary + suggestions text for each spotlighted report, using ...
- Rich colors to emphasize which parts of reports are most important

Here's a very rough starting mockup:

<LabeledImage
	alt="Mockup of a lint report from 'npx @joshuakgoldberg/linter .'. Top-left in red: ./src/base.ts. Bottom-left in red: x Found 7 reports across 3 files. Top-right in gray: Details: enabled Focused view: enabled. Bottom-right in gray: [v] Report 2 of 3 [^] [<] File 2 of 3 [>]. Center: [awaitThenables] A non-Promise (non-Thenable) value is being awaited, with syntax-highlighted await process(), light blue suggestions, a medium gray-green explanation, and green link to example.com/awaitThenables."
	note={`This is a very rough mockup of the "focused" view; please don't read too much into it.`}
	original={{
		href: "https://github.com/JoshuaKGoldberg/repros/tree/linter-report-mockup?tab=readme-ov-file#linter-report-mockup",
		text: "source",
	}}
	src={vscodeTerminalESLintMockup}
	wide
/>

The linter's reporting would have to fall back to more primitive colors, or no colors at all, depending on what the running terminal supports.
And maybe the _Details_ and _Focused view_ settings would persist per-package or per-system?
There's a lot of room for exploration here.

## Comprehensive Rule Documentation

The next step for many developers who receive a lint report is the rule's documentation page.
The typescript-eslint site includes a pretty rich display for rules, similar to many other lint sites:

- High-level ID/name and description
- High-level metadata, such as which config(s) include the rule and whether it requires type information
- Longer description of the rule
- Examples of configuring the rule, as well as its options if they exist
- When _not_ to use the rule
- Links to the rule's source code, test code, and any related other documentation

Each of those sections are must-haves for any lint rule -- especially one in an open source linter or popular plugin.

If I wrote a linter, I would require all those sections be filled out in every core rule's documentation.
I would additionally attempt to make sure any popular plugin website templates include the sections and fill them out too.

## Standardized Rule Metadata

Users like naming and stylistic standardization.
Without consistent patterns, it becomes much more difficult to remember how things work consistently.
Rule names, option names, option value defaults, and other strings users need to think of when using a linter are easier to remember when they're consistent.

Unfortunately, no mainstream linter today is consistent with its choices -- even internally.
Community plugins often make very different and inconsistent choices as well.
This lack of standardization is painful for users.

If I wrote a linter, it would standardize how rules are named and structured.
The next few sections will explain the relevant questions I would standardize answers to.

### Standardized Rule Categories

How do we even categorize rules?
I think developers have generally settled on three categories of lint rules:

- **Formatting**: Rules that don't change the AST
- **Stylistic**: Rules that change the AST but don't change code logic
- **Logical**: Rules that change code logic

Those categories are useful for surfacing to developers why a rule would -or wouldn't- be useful.
Many developers also treat reports differently based on which category they fall into.

If I wrote a linter, I would have all core rules categorized into one of those three categories.
Plugin rules would be encouraged -but not required- to use them as well.

This would allow developers to react to the metadata in their own tooling.
For example, developers might want to use an equivalent of `eslint.rules.customizations` to downgrade stylistic rules to blue info squigglies instead of yellow warnings:

```json
"linter.rules.customizations": [
	{ "category": "stylistic", "severity": "info" }
]
```

### Standardized Rule Messages

The text of rule messages is pretty inconsistent across rules, even within the same linter or plugin.
Older rules tend to have assertive and curt messages, such as:

- [`no-console`](https://eslint.org/docs/latest/rules/no-console): `Unexpected console statement.`
- [`no-empty`](https://eslint.org/docs/latest/rules/no-empty): `Empty block statement.`

I've found that users don't generally react well to curt messages.
They can feel like the linter saying something is _absolutely wrong_, even though most lint rules are sometimes wrong.
There's a reason why many linters put _"When Not To Use"_ sections in their rule documentation pages.

Newer or more recently updated rule messages tend to be more descriptive and speak to the actual problems the rules detect, such as:

- [`no-loss-of-precision`](https://eslint.org/docs/latest/rules/no-useless-assignment): `This number literal will lose precision at runtime.`
- [`no-useless-assignment`](https://eslint.org/docs/latest/rules/no-useless-assignment): `This assigned value is not used in subsequent statements.`

If I wrote a linter, all core rule messages would have consistent phrasing.
They would never be dogmatic or overly prescriptive about what the user "should" do.
They'd instead just speak to the detected potential problem in code.

### Standardized Rule Names

Rule names have to make several choices:

- Abbreviation:
  - Abbreviated: [`no-cond-assign`](https://eslint.org/docs/latest/rules/no-cond-assign), [`no-const-assign`](https://eslint.org/docs/latest/rules/no-const-assign) / [noConstAssign](https://biomejs.dev/linter/rules/no-const-assign)
  - Unabbreviated: [`no-constant-binary-expression`](https://eslint.org/docs/latest/rules/no-constant-binary-expression) / [noConstantBinaryExpression](https://next.biomejs.dev/linter/rules/no-constant-binary-expression)
- Prefixes:
  - Definitive: `@typescript-eslint/ban-ts-comment`, `no-await-in-loop`
  - Loose: `@typescript-eslint/restrict-plus-operands`, `prefer-const`
  - No prefix: `array-callback-return`, `constructor-super`
- Singularity:
  - Singular: `default-case-last`, `for-direction`
  - Plural: `no-magic-numbers`, `require-atomic-updates`

Inconsistent answers to each of those choices lead to user confusion:

- Abbreviation:
  - Memorizing many abbreviations is annoying at best and confusing at worst
  - Some words abbreviate to different meanings, such as "constant" and "const"
- Prefixes:
  - Alphabetical sorting of rules places them similarly prefixed rules together, weirdly
  - Many rules have dropped their prefix after adding an option to invert behavior [^tseslint-discussion-no-prefixing-rule-names]
- Singularity: the least troublesome, but I still find the inconsistency painful

If I wrote a linter, core rule names would make one choice for each of those naming options:

- Abbreviation: no abbreviation, so users won't have to memorize dozens of abbreviations
- Singularity: always plural, as that's how one would describe what rules target
- Prefixes: no prefixes; the rules would be named for the behavior or syntax they target

For example, I would rework the following rule names roughly like:

| Current Rule Name                                                                                   | Reworked Rule Name            |
| --------------------------------------------------------------------------------------------------- | ----------------------------- |
| [array-callback-return](https://eslint.org/docs/latest/rules/array-callback-return)                 | `arrayCallbackReturns`        |
| [ban-ts-comment](https://typescript-eslint.io/rules/ban-ts-comment)                                 | `typescriptCommentDirectives` |
| [constructor-super](https://eslint.org/docs/latest/rules/constructor-super)                         | `constructorSuper`            |
| [default-case-last](https://eslint.org/docs/latest/rules/default-case-last)                         | `defaultCaseLast`             |
| [for-direction](https://eslint.org/docs/latest/rules/for-direction)                                 | `forLoopDirections`           |
| [no-await-in-loop](https://eslint.org/docs/latest/rules/no-await-in-loop)                           | `loopAwaits`                  |
| [no-cond-assign](https://eslint.org/docs/latest/rules/no-cond-assign)                               | `conditionalAssignments`      |
| [no-const-assign](https://eslint.org/docs/latest/rules/no-const-assign)                             | `constAssignments`            |
| [no-constant-binary-expression](https://eslint.org/docs/latest/rules/no-constant-binary-expression) | `constantBinaryExpressions`   |
| [no-floating-promises](https://typescript-eslint.io/rules/no-floating-promises)                     | `floatingPromises`            |
| [no-magic-numbers](https://eslint.org/docs/latest/rules/no-magic-numbers)                           | `magicNumbers`                |
| [prefer-const](https://eslint.org/docs/latest/rules/prefer-const)                                   | `constVariables`              |
| [require-atomic-updates](https://typescript-eslint.io/rules/require-atomic-updates)                 | `atomicUpdates`               |
| [restrict-plus-operands](https://typescript-eslint.io/rules/restrict-plus-operands)                 | `plusOperands`                |

I would also include rule name as a required field in its metadata.
That way, downstream tooling such as documentation generators and unit testers can rely on it.

### Standardized Rule Options

Rule options have to make an even broader, deeper set of choices:

- Format:
  - Array: [`array-type`](https://typescript-eslint.io/rules/array-type), [`no-restricted-component-names`](https://eslint.vuejs.org/rules/no-restricted-component-names)
  - Object with keys for option names: ...almost all other rules
- Name:
  - Plurality:
    - Singular: [`no-implicit-coercion` > `boolean`](https://eslint.org/docs/latest/rules/no-implicit-coercion#options)
    - Plural: [`no-floating-promises` > `checkThenables`](https://typescript-eslint.io/rules/no-floating-promises#checkthenables)
  - Prefix:
    - Turning off checks:
      - `allow*`: [`getter-return` > `allowImplicit`](https://eslint.org/docs/latest/rules/getter-return#options)
      - `ignore*`: [`no-trailing-spaces` > `ignoreComments`](https://eslint.style/rules/js/no-trailing-spaces#ignorecomments)
      - `skip*`: [`no-trailing-spaces` > `skipBlankLines`](https://eslint.style/rules/js/no-trailing-spaces#skipblanklines)
    - Turning on checks:
      - `check*`: [`prevent-abbreviations` > `checkProperties`](https://github.com/sindresorhus/eslint-plugin-unicorn/blob/main/docs/rules/prevent-abbreviations.md#checkproperties)
      - `enforce*`: [`accessor-pairs` > `enforceForClassMembers`](https://eslint.org/docs/latest/rules/accessor-pairs#enforceforclassmembers)
      - `include*`: [`no-duplicate-imports` > `includeExports`](https://eslint.org/docs/latest/rules/no-duplicate-imports#options)
      - `require*`: [`arrow-parens` > `requireForBlockBody`](https://eslint.style/rules/js/arrow-parens#requireforblockbody)
- Value defaults:
  - Boolean values:
    - Off-by-default: [`no-floating-promises` > `ignoreIIFE`](https://typescript-eslint.io/rules/no-floating-promises#ignoreiife)
    - On-by-default: [`no-floating-promises` > `ignoreVoid`](https://typescript-eslint.io/rules/no-floating-promises#ignorevoid)
  - Multi-values:
    - Empty by default: [`no-floating-promises` > `allowForKnownSafeCalls`](https://typescript-eslint.io/rules/no-floating-promises#allowforknownsafecalls)
    - Starting set: [`restrict-template-expressions` > `allow`](https://typescript-eslint.io/rules/restrict-template-expressions#allow)

What a list!

If I wrote a linter, core rule options would make the same choice consistently:

- Format: an object with keys for option names
- Name:
  - Plurality: always plural, as that's how one would describe what rule options target
  - Prefix:
    - `allow*` for options that add in an array of values
    - `check*` for options that turn on a check
    - `ignore*` for options that turn off a check
- Value defaults:
  - Boolean values: off-by-default, for simpler truthiness concepts
  - Multi-values: empty by default, so specifying values doesn't remove defaults
    - If a value is important to include by default, it should be hardcoded on

Here's how the options mentioned in the choices list would look in my linter:

| Current Name                                                                                                                             | Reworked Name        | Current Default | Reworked Default |
| ---------------------------------------------------------------------------------------------------------------------------------------- | -------------------- | --------------- | ---------------- |
| ([`array-type`](https://typescript-eslint.io/rules/array-type))                                                                          | `style`              | `'array'`       | _(same)_         |
| ([`no-restricted-component-names`](https://eslint.vuejs.org/rules/no-restricted-component-names#options))                                | `names`              | `[]`            | _(same)_         |
| [`allow`](https://typescript-eslint.io/rules/restrict-template-expressions#allow)                                                        | _(same)_             | `[{ ... }]`     | `[]`             |
| [`allowForKnownSafeCalls`](https://typescript-eslint.io/rules/no-floating-promises#allowforknownsafecalls)                               | _(same)_             | `[]`            | _(same)_         |
| [`allowImplicit`](https://eslint.org/docs/latest/rules/getter-return#options)                                                            | `ignoreImplicit`     | `false`         | _(same)_         |
| [`boolean`](https://eslint.org/docs/latest/rules/no-implicit-coercion#options)                                                           | `booleans`           | `true`          | `false`          |
| [`checkProperties`](https://github.com/sindresorhus/eslint-plugin-unicorn/blob/main/docs/rules/prevent-abbreviations.md#checkproperties) | _(same)_             | `false`         | _(same)_         |
| [`checkThenables`](https://typescript-eslint.io/rules/no-floating-promises#checkthenables)                                               | _(same)_             | `false`         | _(same)_         |
| [`enforceForClassMembers`](https://eslint.org/docs/latest/rules/accessor-pairs#enforceforclassmembers)                                   | `ignoreClassMembers` | `true`          | `false`          |
| [`ignoreComments`](https://eslint.style/rules/js/no-trailing-spaces#ignorecomments)                                                      | _(same)_             | `false`         | _(same)_         |
| [`ignoreIIFE`](https://typescript-eslint.io/rules/no-floating-promises#ignoreiife)                                                       | _(same)_             | `false`         | _(same)_         |
| [`ignoreVoid`](https://typescript-eslint.io/rules/no-floating-promises#ignorevoid)                                                       | _(same)_             | `true`          | `false`          |
| [`includeExports`](https://eslint.org/docs/latest/rules/no-duplicate-imports#options)                                                    | `checkExports`       | `false`         | _(same)_         |
| [`requireForBlockBody`](https://eslint.style/rules/js/arrow-parens#requireforblockbody)                                                  | `checkBlockBodies`   | `false`         | _(same)_         |
| [`skipBlankLines`](https://eslint.style/rules/js/no-trailing-spaces#skipblanklines)                                                      | `ignoreBlankLines`   | `false`         | _(same)_         |

Oh, and rule options would be sorted alphabetically in their docs pages.
I want to be able to O(log(N)) scan a docs page for a rule option.
Not O(1) search through some arbitrary order.

### Standardized Specifiers

Some rules allow specifying types or values in their options.
For example, [`@typescript-eslint/no-restricted-types`](https://typescript-eslint.io/rules/no-restricted-types) allows specifying types in its `types` option:

```js
"@typescript-eslint/no-restricted-types": [
	"error",
	{
		"types": {
			"SomeType": "Don't use SomeType because it is unsafe",
		},
	},
]
```

The problem with using plain strings to target names is that they are ambiguous.
In the example, _any_ type named `SomeType` would be restricted, even if it is a different type than the one the user intended.

Over in typescript-eslint, we developed a [TypeOrValueSpecifier](https://typescript-eslint.io/packages/type-utils/type-or-value-specifier) format for specifying types or values in options.
It allows users to specify not just the name but also the source -global, package, etc.- of a type or value.
Here's how that would look for specifying `SomeType` from a specific file:

```js
"@typescript-eslint/no-restricted-types": [
	"error",
	{
		"types": [{
			"message": "Don't use SomeType because it is unsafe",
			"type": {
				"from": "file",
				"name": "SomeType",
				"path": "./src/legacy-types.ts",
			},
		}],
	},
]
```

If I wrote a linter, core rules would only ever use the TypeOrValueSpecifier format to specify types or values.
Plugins would be strongly encouraged to use the format instead of ambiguous strings.

<LabeledVideo
	alt="Arnold from Magic School Bus taking off an astronaut helmet in snow and his face covering with ice, leaving dark glasses"
	description="Arnold from Magic School Bus leveling up into Mr. Freeze, much like strings leveling up into TypeOrValueSpecifier."
	original="https://giphy.com/gifs/justin-g-cold-freezing-magic-school-bus-3o6fDMaNGxz2rblFQs"
	src={arnoldMagicSchoolBusMrFreeze}
/>

## Typed Rules

My biggest gripe with linter configuration systems today is that _rule options are not type-checked_.
They're only validated at runtime.
Mainstream linters today have you specify rules as properties an object, where their string key is their plugin name and rule name, and their value is their severity and any options:

```js
{
	"my-plugin/some-rule": ["error", {
		setting: "...",
	}],
}
```

Those string keys have no associated types in config files.
Linters themselves can validate rule options, such as [ESLint's options schemas](https://eslint.org/docs/latest/extend/custom-rules#options-schemas), but those don't translate to TypeScript types.
You don't get editor intellisense while authoring; instead, you have to use [`@eslint/config-inspector`](https://www.npmjs.com/package/@eslint/config-inspector) or run your config to know whether you've mistyped the name of a rule or an option.

I'd love to make a standard plugin creator function that plugin authors are encouraged -even required- to use.
It could take in a set of rules and return some kind of well-typed function.

If I wrote a linter, it would allow [Standard Schema](https://standardschema.dev) descriptions for rule options, which would allow TypeScript-friendly schema validations library like [Zod](https://zod.dev):

```ts
import { createRule, createPlugin } from "@joshuakgoldberg/linter";
import { z } from "zod";

const someRule = createRule({
	options: {
		option: z.string(),
	},
});

export const myPlugin = createPlugin({
	name: "My Plugin",
	rules: [someRule],
});
```

...and in usage could look something like:

```ts
// if-i-wrote-a-linter.config.ts (partial)
({
	rules: [
		myPlugin.rules({
			"some-rule": {
				option: "...",
			},
		}),
	],
});
```

Under that kind of system, users would receive intellisense as they type plugin rules, and all those settings could be type checked.
Doing so would even coincidentally solve the issue of [plugin namespacing and rule config duplication](https://github.com/eslint/eslint/discussions/17766).
Config values would be verified at runtime by the schema validation library.

## Typed Plugin Settings

An even less type-safe part of many current linters' config systems is the [shared `settings` object](https://eslint.org/docs/latest/use/configure/configuration-files#configuring-shared-settings).
You can put whatever you want in there, and any plugin may read from it.

In theory, cross-plugin shared settings can be used for related plugins, while plugin-specific settings are by convention namespaced under their name.
In practice, I don't think I've ever used a shared setting across plugins.

If I wrote a linter, I would have plugins define their own settings and settings types.
They would need to use a Standard Schema validation library too.
It could look something like:

```ts
import { createPlugin } from "@joshuakgoldberg/linter";
import { z } from "zod";

export const myPlugin = createPlugin({
	name: "My Plugin",
	rules: [
		// ...
	],
	settings: {
		mySetting: z.string(),
	},
});
```

...and in usage could look something like:

```ts
// if-i-wrote-a-linter.config.ts (partial)
import { myPlugin } from "@joshuakgoldberg/my-plugin";

myPlugin.settings({
	mySetting: "...",
});
```

As with rules, allowing plugins to define their own settings types would help with the config authoring experience.
It would also newly allow shared settings to be validated by both type-checking and the core linter.
Doing so means plugins can be more confident in defining settings and changing them over time as needed.

## Typed Configuration Files

Linters today fall into two classifications of linter configs:

- Direct JSON ([`biome.json`](https://biomejs.dev/linter/#configuration), [Deno](https://docs.deno.com/runtime/fundamentals/configuration/#linting), [Oxlint](https://oxc.rs/docs/guide/usage/linter#configuration-file))
- Nuanced JS (ESLint: [`.eslintrc.js` (deprecated)](https://eslint.org/docs/latest/use/configure/configuration-files-deprecated), [`eslint.config.js`](https://eslint.org/docs/latest/use/configure/configuration-files))

Direct JSON is a nice and straightforward "walled garden" that shines in small projects.
But I don't think it scales well.
The user experience of typing JSON files isn't great if you're not using a custom editor extension to get JSON intellisense.
Plus, because they can't use native ESM imports, the linters have to implement their own ad hoc module system.

Nuanced JS configurations from ESLint, on the other hand, are "just JavaScript" and so utilize native module importing for plugins, global variables, and shared configurations.
That's great for understandability and simplifying the plugin loading model.
ESLint's flat config is a huge step forward from the confusing `overrides` model of ESLint's legacy configs.

I think ESLint's flat config has learned the hard way:

- With "just" JavaScript objects, there's no way to lint only the user's own config entries [^eslint-issue-change-request-report-unnecessary-config-overrides]
- Directory relativity is confusing when nested configs `import` from a higher-up config [^eslint-issue-change-request-inherit-flat-configs-from-root]
- Global `ignores` needs a separate function or key from local `ignores` [^stackoverflow-parsing-error-was-not-found-by-the-project-service-but-ive-ignored-these-file] [^tseslint-discord-help-eslint-not-ignoring-js-files]
- When plugin configs set file globs and other settings, it's unclear where settings come from

If I wrote a linter, it would have a config system that wholly leans into well-typed functions and objects.
Each line of the config _file_ would set exactly one thing and make it clear what is being set -- even if you don't understand the nuances of the config _system_.

Here's a rough sketch of a starting TypeScript setup, compared to the closest ESLint equivalent:

<Tabs>
	<TabsList>
		<TabsTab id="tab1" controls="panel1" selected>If I Wrote a Linter</TabsTab>
		<TabsTab id="tab2" controls="panel2">ESLint Equivalent</TabsTab>
	</TabsList>
	<TabsPanel id="panel1" labelledby="tab1" selected>

```ts
// if-i-wrote-a-linter.config.ts
import { defineConfig, ts } from "@joshuakgoldberg/linter";

export default defineConfig({
	use: [
		{
			glob: "**/*.ts",
			rules: [ts.configs.logical, ts.configs.stylistic],
		},
	],
});
```

    </TabsPanel>
    <TabsPanel id="panel2" labelledby="tab2">

```ts
// eslint.config.ts
import eslint from "@eslint/js";
import { defineConfig } from "eslint/config";
import tseslint from "typescript-eslint";

export default defineConfig(
	eslint.configs.recommended,
	tseslint.configs.recommended,
	tseslint.configs.stylistic,
);
```

    </TabsPanel>

</Tabs>

That sketch is different from the current ESLint flat config in a few ways:

- Most settings are moved into an explicit `use` array, each with `glob` and `rules`
- The traditional `extends` is merged into `rules` with plugins registering themselves automatically, rather than a separate `plugins` object
- `rules` is a array of type-safe references, rather than a non-type-safe key-value object

Here's a rough sketch that configures rules, ignores some files, and adds a plugin with settings:

<Tabs>
	<TabsList>
		<TabsTab id="tab1" controls="panel1" selected>If I Wrote a Linter</TabsTab>
		<TabsTab id="tab2" controls="panel2">ESLint Equivalent</TabsTab>
	</TabsList>
	<TabsPanel id="panel1" labelledby="tab1" selected>

```ts
// if-i-wrote-a-linter.config.ts
import { defineConfig, ts } from "@joshuakgoldberg/linter";
import { example } from "@joshuakgoldberg/plugin-example";

export default defineConfig({
	ignore: ["lib/"],
	use: [
		{
			exclude: ["**/*.generated.ts"],
			glob: "**/*.ts",
			rules: [
				ts.configs.logical,
				ts.configs.stylistic,
				ts.rules({
					ruleA: false,
					ruleB: true,
					ruleC: {
						someRuleOption: true,
					},
				}),
				example.configs.recommended,
				example.rules({
					ruleD: true,
				}),
				example.settings({
					mySetting: "...",
				}),
			],
		},
	],
});
```

  	</TabsPanel>
	<TabsPanel id="panel2" labelledby="tab2">

```ts
// eslint.config.ts
import eslint from "@eslint/js";
import { example } from "@joshuakgoldberg/plugin-example";
import { defineConfig, globalIgnores } from "eslint/config";
import tseslint from "typescript-eslint";

export default defineConfig(
	eslint.configs.recommended,
	tseslint.configs.recommended,
	tseslint.configs.stylistic,
	example.configs.recommended,
	{
		ignores: ["**/*.generated.ts"],
		rules: {
			"@typescript-eslint/rule-a": "off",
			"@typescript-eslint/rule-b": "error",
			"@typescript-eslint/rule-c": [
				"error",
				{
					someRuleOption: true,
				},
			],
			"example/rule-d": "error",
		},
		settings: {
			example: {
				mySetting: "...",
			},
		},
	},
);
```

    </TabsPanel>

</Tabs>

That sketch shows a few more differences from the current ESLint flat config system:

- `defineConfig()` takes in `ignore` as root-level setting, rather than inline with other settings
  - `exclude` inside `use` objects is intentionally a different key from `ignore` for clarity
  - Note: I also want the config system to ignore files listed in your `.gitignore` by default, in addition to ESLint's defaults of `.git/` and `node_modules/`.
- Settings are specified inline in `use` through their plugin, rather than as a separate catch-all `settings` object

I previously mentioned that I would want to [support common languages in core](/blog/if-i-wrote-a-linter-part-1-architecture#common-languages-in-core).
Here's how the config system would look for a repository that enables logical and stylistic rules on all those languages:

<Tabs>
	<TabsList>
		<TabsTab id="tab1" controls="panel1" selected>If I Wrote a Linter</TabsTab>
		<TabsTab id="tab2" controls="panel2">ESLint Equivalent</TabsTab>
	</TabsList>
	<TabsPanel id="panel1" labelledby="tab1" selected>

```ts
// if-i-wrote-a-linter.config.ts
import { defineConfig, md, json, ts, yml } from "@joshuakgoldberg/linter";

export default defineConfig({
	use: [
		{
			glob: "**/*.ts",
			rules: [ts.configs.logical, ts.configs.stylistic],
		},
		{
			glob: "**/*.json",
			rules: [json.configs.recommended],
		},
		{
			glob: "**/*.md",
			rules: [md.configs.recommended],
		},
		{
			glob: "**/*.yml",
			rules: [yml.configs.recommended],
		},
	],
});
```

  	</TabsPanel>
	<TabsPanel id="panel2" labelledby="tab2">

```ts
// eslint.config.ts
import eslint from "@eslint/js";
import jsonc from "eslint-plugin-jsonc";
import markdown from "eslint-plugin-markdown";
import yml from "eslint-plugin-yml";
import { defineConfig } from "eslint/config";
import tseslint from "typescript-eslint";

export default defineConfig(
	eslint.configs.recommended,
	tseslint.configs.recommended,
	tseslint.configs.stylistic,
	markdown.configs.recommended,
	eslintPluginYml.configs["flat/recommended"],
);
```

    </TabsPanel>

</Tabs>

I don't love that my linter sketch has so many more lines than the ESLint equivalent.
They have fewer overall characters, and I think they're worth it for clarity, but it's a tradeoff.

Another downside of this proposed approach is that it requires the user to know and manage their file extensions themselves.
Knowing that TypeScript files can also be `*.cts`, `*.mts`, `*.tsx`, etc. is a bit of a pain.
Maybe plugins such as the core linter plugins could provide `globs` constants?

```ts
import { defineConfig, md, json, ts, yml } from "@joshuakgoldberg/linter";

export default defineConfig({
	use: [
		{
			glob: ts.globs.all,
			rules: [ts.configs.logical, ts.configs.stylistic],
		},
	],
});
```

...and what about rules that should be different across different files?
Maybe some TypeScript rules skip or apply different logic to `.d.ts` files [^tseslint-issue-no-var-declarations]?

I suspect having the rules react to the extension of the file being linted would be enough.
A rule can skip linting a file based on its file extension, or really any other information it has on the file.
But we'll see.

### Native Workspace Support

Larger web repositories these days are often structured as "monorepos", often using the "workspace" feature of their package manager and other tools.
Workspaces are particularly useful when different packages in the same repository use some very different frameworks.

If I wrote a linter, I would want native support for workspaces.
I think a root-level lint config file should be able to define common rules and settings for all workspaces.
It should also be able to define where the linter should look for workspace-specific config files.
Then, each workspace could define its own config file that extends the root config and overrides any settings it wants.

Here's a rough sketch of what the root monorepo config could like with a config system inspired by [Vitest workspaces](https://vitest.dev/guide/workspace.html):

```ts
// if-i-wrote-a-linter.config.ts
import { defineConfig, ts } from "@joshuakgoldberg/linter";

export default defineConfig({
	use: [
		{
			glob: "**/*.ts",
			rules: [ts.configs.logical, ts.configs.stylistic],
		},
	],
	workspaces: ["packages/*"],
});
```

Each `packages/*` directory could have its own config that explicitly inherits from the root config:

```ts
// packages/example/if-i-wrote-a-linter.config.ts
import { defineConfig } from "@joshuakgoldberg/linter";
import { example } from "@joshuakgoldberg/plugin-example";

export default defineConfig({
	from: "../..",
	use: [
		{
			exclude: ["**/*.generated.ts"],
			glob: "**/*.ts",
			rules: [
				example.configs.recommended,
				example.rules({
					ruleD: true,
				}),
				example.settings({
					mySetting: "...",
				}),
			],
		},
	],
});
```

<LabeledVideo
	alt="Elsa from Frozen in an ice chamber flings a blast of sparkling ice onto pillars around her"
	description="Elsa from Frozen configuring her various workspaces with shared root settings."
	original="https://giphy.com/gifs/disneyanimation-film-animation-disney-k4wwWSRq9CoSI"
	src={elsaFloorIcePillars}
/>

## Inline Snapshot Unit Tests

I like the design of [ESLint's `RuleTester`](https://eslint.org/docs/latest/integrate/nodejs-api#ruletester) (and [typescript-eslint's `RuleTester` extension](https://typescript-eslint.io/packages/rule-tester)).
`RuleTester`'s API allows for clear, succinct descriptions of many isolated test cases at once.
I prefer it over the [TSLint `*.ts.lint` test files](https://palantir.github.io/tslint/develop/testing-rules) that put all test cases into one big file namespace.

Here's an example of a `RuleTester` test for a TypeScript rule:

```ts
import { RuleTester } from "eslint";
import rule from "./preferConst.js";

const ruleTester = new RuleTester();

ruleTester.run("prefer-const", rule, {
	invalid: [
		{
			code: `let value = 123;`,
			output: `const value = 123;`,
			errors: [
				{
					column: 5,
					line: 1,
					data: { name: "value" },
					messageId: "preferConst",
				},
			],
		},
	],
	valid: [
		`const value = 123;`,
		`
			let value = 123;
			value = 456;
		`,
	],
});
```

I don't love that we have to specify the rule name manually.
That's easily solvable by [Standardized Rule Names](#standardized-rule-names)'s note of making that a required rule property.

I also don't love that the `RuleTester` class is packaged with the linter itself.
Doing so is convenient for plugin developers, but it means the code bloats users' package installations.

My biggest gripes with `RuleTester` are around the `errors` array:

- It doesn't show the full error message, just the data used to create it
  - Not managing long messages is nice, but text formatting issues can more easily sneak in
- Specifying location data as 0-4 of `column`, `endColumn`, `line`, and/or `endLine`:
  - Adding new cases and updating tests for rule changes is cumbersome
  - Tests tend to be inconsistent about how much location data they include

What I really want here is the best of three worlds:

- ESLint's `RuleTester`: clear and succinct inline cases
- TSLint's lint files: quick visual display of report spans and messages
- Jest/Vitest-style inline snapshots [^vitest-inline-snapshots]: being able to auto-update those report spans

If I wrote a linter, it would provide:

- A `RuleTester` equivalent that defines rule reports in an inline string snapshot
- A first-party plugin that auto-fixes report snapshots to match the current rule reports

Here's how that could look in practice:

```ts
import { RuleTester } from "@joshuakgoldberg/rule-tester";
import rule from "./preferConst.js";

const ruleTester = new RuleTester();

ruleTester.run(rule, {
	invalid: [
		{
			code: `let value = 123;`,
			output: `const value = 123;`,
			report: `
				let value = 123;
				    ^^^^^
				    [preferConst] Prefer using 'const' for variables that are never reassigned.
			`,
		},
	],
	valid: [
		`const value = 123;`,
		`
			let value = 123;
			value = 456;
		`,
	],
});
```

<small>
	<em>
		(I'd use `~`, not `^`, for squigglies, but right now they break syntax
		highlighting in my MDX extension (known bug)...)
	</em>
</small>

`report` would only show the reported line, or the first and last lines if a multi-line report.

I'll talk more in the next post in this series about the first-party plugin and other ecosystem tooling.

<LabeledVideo
	alt="Anna from Frozen as a young girl knocking on Elsa's door, asking: 'do you want to build a linter?'"
	description="Anna seeking to explore new and fun ways to improve the developer experience of web linting."
	src={doYouWannaBuildALinter}
/>

## Up Next

This post ballooned in size from what I thought it would be.
There are a lot of fun ideas in here and I'm not sure how many of them are practically doable.
But I think it'd be great to achieve the stated goals for an approachable, clear, and friendly linting user experience.

Next week I'll post a next entry in this series that focuses on ecosystem work.
If these first two posts were of interest to you I think you'll be interested in that one too!

> ðŸ’¡ This post is the second in a series:
>
> <br />
>
> - [Part 1: Architecture](/blog/if-i-wrote-a-linter-part-1-architecture)
> - ðŸ‘‰ [Part 2: Developer Experience](/blog/if-i-wrote-a-linter-part-2-developer-experience)
> - [Part 3: Ecosystem](/blog/if-i-wrote-a-linter-part-3-ecosystem)
> - [Part 4: Summary](/blog/if-i-wrote-a-linter-part-4-summary)

### Acknowledgements

Thanks in particular to [Kirk Waiblinger](https://github.com/kirkwaiblinger), fellow typescript-eslint team member, for very helpful advice on the config file format.
Kirk ideated preset `glob` values and helped with balancing clarity of language configurations with its verbosity.

Additional thanks to [Arend van Beelen](https://fosstodon.org/@arendjr@mstdn.social), [Dimitri Mitropoulos (Michigan TypeScript)](https://michigantypescript.com), and [@tonywu6.org](https://bsky.app/profile/tonywu.org) for suggesting references of CLI prior art.
Dimitri also helped ideate the rich CLI output format and what to show in the different views.

[^biome-cli-reference]: [Biome `no-aria-unsupported-elements` Examples > Invalid](https://biomejs.dev/linter/rules/no-aria-unsupported-elements/#invalid)

[^eslint-issue-change-request-inherit-flat-configs-from-root]: [eslint/eslint#18385 Change Request: Make it easier to inherit flat configs from the repo root #18385](https://github.com/eslint/eslint/issues/18385)

[^eslint-issue-change-request-report-unnecessary-config-overrides]: [eslint/eslint#15476 Change Request: report unnecessary config overrides](https://github.com/eslint/eslint/issues/15476)

[^eslint-pr-docs-warn-severity]: [eslint/eslint#16696 docs: Add explanation of when to use 'warn' severity](https://github.com/eslint/eslint/issues/16696)

[^pretty-ts-errors-docs-hide-original-errors]: [yoavbls/pretty-ts-errors > docs/hide-original-errors.md](https://github.com/yoavbls/pretty-ts-errors/blob/main/docs/hide-original-errors.md)

[^rust-ariadne]: [zesterer/ariadne](https://github.com/zesterer/ariadne)

[^rust-codespan]: [brendanzlab/codespan](https://github.com/brendanzlab/codespan)

[^rust-miette]: [zkat/miette](https://github.com/zkat/miette)

[^stackoverflow-parsing-error-was-not-found-by-the-project-service-but-ive-ignored-these-file]: [StackOverflow: Parsing error: was not found by the project service, but I've ignored these files](https://stackoverflow.com/a/78873727/1830407)

[^tseslint-discord-help-eslint-not-ignoring-js-files]: [Discord help thread: Eslint not ignoring .js files and throwing Definition for rule ... not found error](https://discord.com/channels/1026804805894672454/1283776448188121158)

[^tseslint-discussion-no-prefixing-rule-names]: [Suggestion: standardize against prefixing rule names with "no-"](https://github.com/typescript-eslint/typescript-eslint/discussions/6022)

[^tseslint-issue-no-var-declarations]: [typescript-eslint/typescript-eslint#7941 Base rule extension: no-var configuration for declarations](https://github.com/typescript-eslint/typescript-eslint/issues/7941)

[^tseslint-shared-configs]: [typescript-eslint > Users > Shared Configs](https://typescript-eslint.io/users/configs)

[^tseslint-troubleshooting-performance-import]: [typescript-eslint Troubleshooting & FAQs > Typed Linting > Performance > `eslint-plugin-import`](https://typescript-eslint.io/troubleshooting/typed-linting/performance#eslint-plugin-import)

[^tseslint-troubleshooting-performance-prettier]: [typescript-eslint Troubleshooting & FAQs > Typed Linting > Performance > `eslint-plugin-prettier`](https://typescript-eslint.io/troubleshooting/typed-linting/performance#eslint-plugin-prettier)

[^tseslint-troubleshooting-performance-stylistic]: [typescript-eslint Troubleshooting & FAQs > Typed Linting > Performance > `@stylistic/ts/indent` and other stylistic rules rules](https://typescript-eslint.io/troubleshooting/typed-linting/performance#stylistictsindent-and-other-stylistic-rules-rules)

[^tsslint-cli-reference]: [johnsoncodehk/tsslint#50 Include screenshot/gif of the CLI somewhere in this repo?](https://github.com/johnsoncodehk/tsslint/issues/50)

[^typescript-pull-orta-cli-reference]: [Microsoft/TypeScript#49668 Compiler CLI output format update v2](https://github.com/microsoft/TypeScript/issues/45717)

[^vitest-cli-reference]: [Vitest Command Line Interface](https://vitest.dev/guide/cli)

[^vitest-inline-snapshots]: [Vitest Inline Snapshots](https://vitest.dev/guide/snapshot.html#inline-snapshots)

[^vscode-allow-diagnostics-messages-markdown-content]: [microsoft/vscode#54272](https://github.com/microsoft/vscode/issues/54272)

[^vscode-eslint-issue-markdown-report]: [microsoft/vscode-eslint#1761 Support for markdown in the rule's message report](https://github.com/microsoft/vscode-eslint/issues/1761)

[^vscode-rich-editor-support]: [microsoft/vscode `vscode.d.ts`: `DecorationOptions` > `hoverMessage`](https://github.com/microsoft/vscode/blob/977af64fdff5cd967989749204d1e778dfe86f31/src/vscode-dts/vscode.d.ts#L1216)
