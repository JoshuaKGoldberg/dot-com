---
pubDate: 2025-05-15
description: "This is how I would steer a new ecosystem around a modern linter from scratch: TODO."
image:
  alt: "TODO"
  src: "~/assets/blog/sisyphus.jpg"
title: "If I Wrote a Linter, Part 3: Ecosystem"
---

import {
	Tabs,
	TabsList,
	TabsTab,
	TabsPanel,
} from "accessible-astro-components";

import tevyeDancing from "~/assets/blog/tevye-dancing.webp";
import LabeledImage from "~/components/blog/mdx/LabeledImage.astro";
import LabeledVideo from "~/components/blog/mdx/LabeledVideo.astro";
import tslintToESLintConfig from "~/assets/blog/tslint-to-eslint-config.png";

Today's web linters are great.
[ESLint](https://eslint.org) is robust and has a huge ecosystem of plugins and configs.
Newer native speed linters such as [Biome](https://biomejs.dev), [`deno lint`](https://lint.deno.land), and [Oxlint](https://github.com/oxc-project/oxc) are fast and easy to set up with their own burgeoning ecosystems.

I've been working on TypeScript linting for almost a decade.
I started contributing to [TSLint](https://palantir.github.io/tslint) community projects in 2016 and am now a number of the [typescript-eslint](https://github.com/typescript-eslint/typescript-eslint) and [ESLint](https://github.com/eslint/eslint) teams.
Based on those years of various linters, I've collected a large set of design ideas that I want to try.

I see a linter that is **fast by default**, **powerful upon request**, and **straightforward to configure**.
This post is how I would craft the ecosystem around it.

TODO: opening meme

> ðŸ’¡ This post is the third in a series:
>
> <br />
>
> - [Part 1: Architecture](/blog/if-i-wrote-a-linter-part-1-architecture)
> - [Part 2: Developer Experience](/blog/if-i-wrote-a-linter-part-2-developer-experience)
> - ðŸ‘‰ [Part 3: Ecosystem](/blog/if-i-wrote-a-linter-part-3-ecosystem)
> - Part 4: Summary _([coming soon](https://github.com/JoshuaKGoldberg/dot-com/pull/421 "dot-com pull request 421 Part 4: Summary"))_

## Shared Glossary

Many important linting terms have inconsistent usage or even definitions in the wild today.
For example, _"stylistic"_ can alternately refer to:

- [Stylistic (Rule)](https://eslint.org/docs/latest/use/core-concepts/glossary#stylistic-rule): The category of lint rules that enforce formatting, naming conventions, or consistent usage of equivalent syntaxes
- [ESLint Stylistic](https://eslint.style): The plugin that ESLint's formatting rules were migrated to, along with a small selection of non-formatting stylistic rules
- [typescript-eslint's stylistic shared configs](https://typescript-eslint.io/users/configs#stylistic), which enforce consistent usage of equivalent syntaxes, as well as general TypeScript best practices that don't impact program logic

...huh!?

Other ambiguous terms include:

- _"Config"_: a shared config, or a configuration file?
- _"Format"_: formatting rules, or a formatter like Prettier, or code to prints ESLint reports?

I work on linters and I have a hard time keeping this all straight.
Now imagine how confusing this all is for someone new to linting, and/or who doesn't care much about their linter.

If I wrote a linter, I would continue the [ESLint Glossary](https://eslint.org/docs/latest/use/core-concepts/glossary) work by defining single recommended terms for all the shared linting concepts.
I hope this would help reduce naming conflicts such as what we're seeing with _"config"_, _"format"_, and _"stylistic"_.

## Common Core Plugins

One of the hardest parts of figuring out a project's ecosystem is knowing what to put in core or delegate to users.
I've seen two prevailing strategies in the wild:

- Lean core (ESLint): only including rules that pertain to JavaScript itself, which reduces its maintenance burden and allows plugins to iterate and learn
- Heavy core (OXLint, Biome): including common plugins, which increases the power of the linter out of the box and reduces configuration complexity

Both strategies have merit in allowing the ecosystem to iterate and learn in areas that aren't solidified yet or are too project-dependent for core.
Putting a rule in core is a heavyweight action for that rule.
Core linter rules tend to be more stable than plugin rules, but development slows down as the core team has to be more careful about breaking changes.

If I wrote a linter, I would include all plugins in core that are:

- Common to roughly all projects that would use the linter
- Stable enough that they are not still rapidly iterating and making breaking changes

That includes taking rules from the following plugins:

- [`@eslint-community/eslint-plugin-eslint-comments`](https://www.npmjs.com/package/@eslint-community/eslint-plugin-eslint-comments)
- [`eslint-plugin-import`](https://github.com/import-js/eslint-plugin-import)
- [`eslint-plugin-jsdoc`](https://github.com/gajus/eslint-plugin-jsdoc)
- [`eslint-plugin-package-json`](https://github.com/JoshuaKGoldberg/eslint-plugin-package-json)
- [`eslint-plugin-promise`](https://github.com/eslint-community/eslint-plugin-promise)
- [`eslint-plugin-n`](https://github.com/gajus/eslint-plugin-jsdoc)
- [`eslint-plugin-regexp`](https://github.com/gajus/eslint-plugin-regexp)
- [`eslint-plugin-unicorn`](https://github.com/sindresorhus/eslint-plugin-unicorn)

> Note also from [Part 1 > Core Common Languages](/blog/if-i-wrote-a-linter-part-1-architecture#core-common-languages) that JSON, Markdown, TypeScript, and YML plugins would also be in core.

That does not include the following plugins:

- [`@eslint-community/eslint-plugin-n`](https://www.npmjs.com/package/@eslint-community/eslint-plugin-n): not all projects use Node.js
- [`eslint-plugin-jsx-a11y`](https://github.com/jsx-eslint/eslint-plugin-jsx-a11y) or other frontend plugins: not all projects include frontend code
- [`eslint-plugin-perfectionist`](https://github.com/azat-io/eslint-plugin-perfectionist): not enough of the community is bought in _(yet?)_
- [`eslint-plugin-vitest`](https://github.com/vitest-dev/eslint-plugin-vitest) or other test plugins: different projects use different test frameworks

Those plugins are important and should be discoverable by users.
The next two sections in this post describe how the linter would help promote them to users.

## Community Organization

The [ESLint Community organization](https://github.com/eslint-community) is wonderful.
I think it serves a great need for housing high-value community projects that are not able to be part of ESLint core.
It's a kind of "next step" for finding plugins outside of ESLint core -- not quite "first party", and not an external "third party".

If I wrote a linter, it would have a similar community organization.
It would have guidelines for inclusion, including:

- Actively supporting new core linter minor versions soon after release
- Adherence to the shared linting glossary
- Documenting all configs, rules, and rule options
- Maximum time to triage new issues and pull requests
- Minimum numbers of consuming projects and weekly downloads
- Not being specific to any one userland framework
- Providing metadata alongside the `package.json` such as:
  - Names of any dependencies the plugin is directly for (e.g. `"lodash"`, `"react"`)
  - Text of when to use the plugin and each of its configs

To start, it would include equivalents of:

- [`@eslint/css`](https://github.com/eslint/css)
- [`@html-eslint/eslint-plugin`](https://github.com/yeonjuan/html-eslint)
- [`eslint-fix-utils`](https://github.com/JoshuaKGoldberg/eslint-fix-utils)
- [`eslint-plugin-jsx-a11y`](https://github.com/jsx-eslint/eslint-plugin-jsx-a11y)
- [`eslint-plugin-eslint-plugin`](https://github.com/eslint-community/eslint-plugin-eslint-plugin)

Those community plugins would be included in ecosystem tests for the core linter to ensure new core linter releases don't unexpectedly break them [^eslint-rfc-ecosystem-tests].

## Plugin Registry

Finding the right third-party linter plugins for a project today is a pain.
ESLint does not yet have a centralized plugin registry [^eslint-issue-plugins-eslint-org].
The best process I've come to recommend is:

1. Read [dustinspecker/awesome-eslint](https://github.com/dustinspecker/awesome-eslint)
2. For each dependency relied upon, search online for "eslint plugin" and that dependency name

That's a very unreliable process.
Determining which plugins are popular or still actively maintained is time-consuming and unreliable [^awesome-eslint-issue-out-of-date].

If I wrote a linter, I would create a centralized plugin registry of popular userland plugins.
It would have similar guidelines for inclusion as the community organization, but with more lenient numbers, and allowing framework-specific plugins.
The registry would automatically update plugin metadata such as:

- How recently the plugin was updated
- How many open issues exist that haven't been interacted with by a maintainer
- The latest version of the linter that the plugin formally supports

Plugins that get too out-of-date on any of those metrics would be marked as such in the UI.
That would allow users to filter and search for plugins that are, say, actively maintained and support the latest version of the linter.

The registry would be exposed to users in two ways:

- API: allowing tooling to be built using known plugin metadata, such as...
- Website: allowing users to search on that metadata

Essentially, this would be a tailored _npm for linter plugins_ [^lintbase-about].

## Config Initializer

Every mainstream linter comes with some kind of configuration file initialization CLI: [`@eslint/config`](https://eslint.org/docs/latest/use/getting-started#quick-start), [`biome init`](https://biomejs.dev/guides/getting-started/#configuration), [`oxlint --init`](https://oxc.rs/docs/guide/usage/linter/cli.html#basic-configuration), etc.
Good!
Initialization CLIs help users get started quickly and with confidence their configuration is correct.

My only gripe with those CLIs is that they only cover a few base starting points.
You're left on your own to figure out how to add plugins not explicitly hardcoded into the CLI.
`@eslint/config`, for example, offers to support the React and Vue frameworks out-of-the-box, but that's it.

If I wrote a linter, its config initializer would use plugin data from the centralized plugin registry to make the setup experience dynamic.
If run in a project with existing dependencies, it would offer to add the plugins for those plugins into the created configuration.
It would also offer the user an input to provide dependency names they want to search on plugins for.

It'd probably have to use a templating system like [Bingo's Stratum](https://www.create.bingo/engines/stratum/about) so plugins can define how they add to a config file.

### Initialized Examples

Initialization CLIs are great for previewing changes locally, but many users also want to see examples in documentation form.
Creating up-to-date documentation examples is a pain to do manually -- especially for community-authored plugins specific to frameworks.
But, once we factor in the centralized plugin registry and config initializer templating, we can automate that process!

If I wrote a linter, it would automatically keep a known set of example repositories up-to-date with the latest versions of the linter and a plugin each.
CI actions would run that update the templates whenever a new version of a dependency is released.

I happened to implement a similar feature for my [Bingo](https://create.bingo) and [create-typescript-app](https://github.com/JoshuaKGoldberg/create-typescript-app) projects recently.
[bingo-js > Example Repositories](https://github.com/bingo-js/#example-repositories) contains about a dozen repositories auto-generated from templates and kept up-to-date in CI.
They each run a GitHub Action that checks in any changes from re-running the template on Renovate pull requests.

## One-Way Compatibility

If you want to get users to adopt a new linter, you need to make it easy for them to migrate from the current dominant market leader: ESLint.
That migration story needs to be as pleasant as possible.
If users can't switch from an existing setup confidently and quickly, they won't.

I think most linters today target _two-way compatibility_.
Meaning: they support all the _use cases_ ESLint does by porting close equivalents to all of ESLint's _features_.

Two-way compatibility doesn't necessarily mean _full_ compatibility.
Details might not be the same or fully implemented, such as linters not _(yet?)_ [^oxc-issue-linter-config-file] supporting JS configs rather than JSON.
But concepts are similar and users can migrate their configs with minimal changes [^biome-guide-migrate-eslint-prettier].

If I wrote a linter, I would target _one-way compatibility_.
Meaning: there would be support for all the _use cases_ ESLint supports, but they might not map up to ESLint's _features_.
For drastically changed concepts, those migrations would one-way port to the linter's equivalents -- which might not preserve the exact original semantics.

Taking errors vs. warnings as an example, the equivalent would be the new linter's "gradual onboardings" system:

- _Feature_: errors vs. warnings would not be preserved
- _Use case_: marking rules as not ready to cause errors yet would still be supported

Building a first-class gradual onboardings system into the linter would give more granular control over the rule onboarding process.
The new system would, I think, actually be _better_ at supporting the _use case_ by replacing, rather than porting, the specific _feature_.

### Compatibility Layers

Existing userland ESLint plugins need to be consumable by the new linter.
Getting users to write -let alone maintain- a plugin in one linter is hard enough.
Asking them to additionally work on one more implementation for each new linter is a non-starter.

If I wrote a linter, it would have a compatibility layer for ESLint plugins.
It would allow you to install an ESLint plugin and directly use its configs and rules in your lint configuration.

Here's a rough sketch of how it might look for a hypothetical `@joshuakgoldberg/eslint-plugin`:

```ts
// if-i-wrote-a-linter.config.ts
import { defineConfig, ts } from "@joshuakgoldberg/linter";
import { wrapPlugin } from "@joshuakgoldberg/linter-eslint";
import { joshuakgoldberg } from "@joshuakgoldberg/eslint-plugin";

export default defineConfig({
	use: [
		{
			glob: "**/*.ts",
			rules: [
				ts.configs.logical,
				ts.configs.stylistic,
				wrapPlugin(joshuakgoldberg.configs.recommended),
			],
		},
	],
});
```

[ESLint's compatibility utilities](https://eslint.org/blog/2024/05/eslint-compatibility-utilities) are a good reference of prior art for compatibility layers.

### Configuration Migration

Existing user configuration files need to be automatically portable to the new linter's format.
Getting users to touch their configuration files in one linter -let alone understand mapping between to linters- is hard enough.
Asking them to manually rewrite a configuration file in a new format is a non-starter.

[ESLint's configuration migrator](https://eslint.org/docs/latest/use/configure/migration-guide#migrate-your-config-file) and [tslint-to-eslint-config](https://github.com/typescript-eslint/tslint-to-eslint-config) are a good references of prior art for migration tooling.
I'm particularly fond of how tslint-to-eslint-config aggressively suggests that users rethink how their configuration files are structured:

<LabeledImage
	alt="TODO"
	note="Example of running npx tslint-to-eslint-config on a project with a TSLint config file"
	original={{
		href: "https://github.com/JoshuaKGoldberg/repros/tree/TODO?tab=readme-ov-file#linter-report-mockup",
		text: "source",
	}}
	src={tslintToESLintConfig}
	wide
/>

If I wrote a linter, it would provide a configuration migrator utility for ESLint configuration files.
It would take an existing ESLint configuration file and output as close an approximation in the new linter configuration file as possible.

It would also provide flags for whether to adopt practices recommended by the new linter:

- Adding any plugins from the [plugin registry](#plugin-registry) relevant to existing project dependencies
- Enabling the linter's gradual onboardings system for rules previously set to warn [^goldblog-linter-part-2-only-errors]
- If formatting rules are detected, turn them off and instead use the linter's formatter coordination [^goldblog-linter-part-1-formatting-coordination]
- Using the recommended configs from the linter and its plugins

Those flags would allow the migration tool to be used as more than just a single-shot _"closest possible equivalent"_ tool.
It would also help users migrate to best practices and more powerful linter configurations.

[^awesome-eslint-issue-out-of-date]: [dustinspecker/awesome-eslint#245 fix: remove deprecated and 404 links](https://github.com/dustinspecker/awesome-eslint/pull/245): I noticed over a dozen archived or dead links in the list while working on this blog post.

[^biome-guide-migrate-eslint-prettier]: [Biome > Migrate from ESLint and Prettier](https://biomejs.dev/guides/migrate-eslint-prettier)

[^eslint-issue-change-request-apply-suggestions-to-other-files]: [eslint/eslint#17881 Change Request: Provide a way for rules to apply suggestions to other files](https://github.com/eslint/eslint/issues/17881])

[^eslint-issue-plugins-eslint-org]: [eslint/eslint#18824 Create plugins.eslint.org website](https://github.com/eslint/eslint/issues/18824)

[^eslint-issue-plugins-eslint-org]: [eslint/eslint#18824 Create plugins.eslint.org website](https://github.com/eslint/eslint/issues/18824)

[^eslint-rfc-ecosystem-tests]: [feat: Introduce ecosystem tests for popular plugins](https://github.com/eslint/rfcs/pull/127)

[^goldblog-linter-part-1-formatting-coordination]: [If I Wrote a Linter, Part 1: Architecture > Formatting Coordination](/blog/if-i-wrote-a-linter-part-1-archirecture#formatting-coordination)

[^goldblog-linter-part-2-only-errors]: [If I Wrote a Linter, Part 2: Developer Experience > Only Errors](/blog/if-i-wrote-a-linter-part-2-developer-experience#only-errors)

[^jsdoc-granular-flat-typescript-configs]: [eslint-plugin-jsdoc: Configuration > Granular Flat Configs](https://github.com/gajus/eslint-plugin-jsdoc?tab=readme-ov-file#granular-flat-configs)

[^lintbase-about]: [Lintbase](https://github.com/bmish/lintbase) was a project that aimed to do what I'm proposing.

[^oxc-issue-linter-config-file]: [osc-project/oxc#10935 linter: intelligent config file](https://github.com/oxc-project/oxc/issues/10935)

[^tseslint-discussion-intent-to-use-checker-is-type-assignable-to]: [typescript-eslint/typescript-eslint#7936 ðŸ”“ Intent to use: checker.isTypeAssignableTo](https://github.com/typescript-eslint/typescript-eslint/discussions/7936)

[^tseslint-explore-ts-vfs]: [typescript-eslint/typescript-eslint#1891 Explore switching tests to @typescript/vfs](https://github.com/typescript-eslint/typescript-eslint/issues/1891)

[^typescript-eslint-configs]: [typescript-eslint > Shared Configs](https://typescript-eslint.io/users/configs)
